<!DOCTYPE html>
<html>
<head>
  <title>New Operations Test (ArgMin, Pad, Tile, Slice, OneHot, CumSum)</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #1a1a2e; color: #eee; }
    .pass { color: #4ade80; }
    .fail { color: #f87171; }
    pre { background: #16213e; padding: 15px; border-radius: 8px; overflow-x: auto; }
  </style>
</head>
<body>
  <h1>New Operations Test (ArgMin, Pad, Tile, Slice, OneHot, CumSum)</h1>
  <pre id="output"></pre>
  <script type="module">
    import { GPURuntime, GraphExecutor } from '../src/runtime.js';
    import { Compiler } from '../dist/bundle.js';
    
    const log = (msg) => {
      document.getElementById('output').textContent += msg + '\n';
      console.log(msg);
    };
    
    async function runTests() {
      log('=== New Operations Tests ===\n');
      
      const runtime = new GPURuntime();
      await runtime.init();
      log('✓ Runtime initialized\n');

      // Test 1: ArgMin
      log('Test 1: ArgMin (index of minimum value)');
      try {
        const graph1 = Compiler.createGraph();
        const x1 = Compiler.input(graph1, [8], "input");
        const y1 = Compiler.argmin(graph1, x1, 0);
        Compiler.markOutput(graph1, y1);
        const compiled1 = Compiler.compile(graph1);
        const executor1 = new GraphExecutor(runtime, compiled1);
        await executor1.init();
        
        const input1 = new Float32Array([5, 2, 8, 1, 9, 3, 7, 4]);
        const output1 = await executor1.execute(input1);
        log(`  Input: [${Array.from(input1)}]`);
        log(`  ArgMin output: ${output1[0]} (expected: 3, since input[3]=1 is minimum)`);
        log(`  ${output1[0] === 3 ? 'PASS ✓' : 'FAIL ✗'}\n`);
        executor1.destroy();
      } catch (e) {
        log(`  FAIL ✗: ${e.message}\n`);
        console.error(e);
      }

      // Test 2: Pad
      log('Test 2: Pad (add padding to tensor)');
      try {
        const graph2 = Compiler.createGraph();
        const x2 = Compiler.input(graph2, [4], "input");
        // pads format: [before_dim0, after_dim0] for 1D
        const y2 = Compiler.pad(graph2, x2, [2, 3], 0.0);
        Compiler.markOutput(graph2, y2);
        const compiled2 = Compiler.compile(graph2);
        const executor2 = new GraphExecutor(runtime, compiled2);
        await executor2.init();
        
        const input2 = new Float32Array([1, 2, 3, 4]);
        const output2 = await executor2.execute(input2);
        log(`  Input: [${Array.from(input2)}] (length 4)`);
        log(`  Pad [2, 3] with 0.0`);
        log(`  Output: [${Array.from(output2).map(v => v.toFixed(1))}] (length ${output2.length})`);
        log(`  Expected: [0, 0, 1, 2, 3, 4, 0, 0, 0] (length 9)`);
        const expected2 = [0, 0, 1, 2, 3, 4, 0, 0, 0];
        const pass2 = output2.length === 9 && expected2.every((v, i) => Math.abs(output2[i] - v) < 0.01);
        log(`  ${pass2 ? 'PASS ✓' : 'FAIL ✗'}\n`);
        executor2.destroy();
      } catch (e) {
        log(`  FAIL ✗: ${e.message}\n`);
        console.error(e);
      }

      // Test 3: Tile
      log('Test 3: Tile (repeat tensor)');
      try {
        const graph3 = Compiler.createGraph();
        const x3 = Compiler.input(graph3, [3], "input");
        const y3 = Compiler.tile(graph3, x3, [3]);  // repeat 3 times
        Compiler.markOutput(graph3, y3);
        const compiled3 = Compiler.compile(graph3);
        const executor3 = new GraphExecutor(runtime, compiled3);
        await executor3.init();
        
        const input3 = new Float32Array([1, 2, 3]);
        const output3 = await executor3.execute(input3);
        log(`  Input: [${Array.from(input3)}]`);
        log(`  Tile [3] (repeat 3x)`);
        log(`  Output: [${Array.from(output3)}]`);
        log(`  Expected: [1, 2, 3, 1, 2, 3, 1, 2, 3]`);
        const expected3 = [1, 2, 3, 1, 2, 3, 1, 2, 3];
        const pass3 = output3.length === 9 && expected3.every((v, i) => Math.abs(output3[i] - v) < 0.01);
        log(`  ${pass3 ? 'PASS ✓' : 'FAIL ✗'}\n`);
        executor3.destroy();
      } catch (e) {
        log(`  FAIL ✗: ${e.message}\n`);
        console.error(e);
      }

      // Test 4: Slice
      log('Test 4: Slice (extract subtensor)');
      try {
        const graph4 = Compiler.createGraph();
        const x4 = Compiler.input(graph4, [8], "input");
        // slice from index 2 to 6, axis 0, step 1
        const y4 = Compiler.slice_(graph4, x4, [2], [6], [0], [1]);
        Compiler.markOutput(graph4, y4);
        const compiled4 = Compiler.compile(graph4);
        const executor4 = new GraphExecutor(runtime, compiled4);
        await executor4.init();
        
        const input4 = new Float32Array([0, 1, 2, 3, 4, 5, 6, 7]);
        const output4 = await executor4.execute(input4);
        log(`  Input: [${Array.from(input4)}]`);
        log(`  Slice [2:6]`);
        log(`  Output: [${Array.from(output4)}]`);
        log(`  Expected: [2, 3, 4, 5]`);
        const expected4 = [2, 3, 4, 5];
        const pass4 = output4.length === 4 && expected4.every((v, i) => Math.abs(output4[i] - v) < 0.01);
        log(`  ${pass4 ? 'PASS ✓' : 'FAIL ✗'}\n`);
        executor4.destroy();
      } catch (e) {
        log(`  FAIL ✗: ${e.message}\n`);
        console.error(e);
      }

      // Test 5: OneHot
      log('Test 5: OneHot (indices to one-hot encoding)');
      try {
        const graph5 = Compiler.createGraph();
        const x5 = Compiler.input(graph5, [4], "input");
        const y5 = Compiler.oneHot(graph5, x5, 5);  // depth=5, so 5 classes
        Compiler.markOutput(graph5, y5);
        const compiled5 = Compiler.compile(graph5);
        const executor5 = new GraphExecutor(runtime, compiled5);
        await executor5.init();
        
        const input5 = new Float32Array([0, 2, 1, 4]);  // class indices
        const output5 = await executor5.execute(input5);
        log(`  Input (class indices): [${Array.from(input5)}]`);
        log(`  OneHot depth=5`);
        log(`  Output shape: [4, 5] = 20 elements`);
        log(`  Output: [${Array.from(output5).map(v => v.toFixed(0)).join(',')}]`);
        log(`  Expected: [1,0,0,0,0, 0,0,1,0,0, 0,1,0,0,0, 0,0,0,0,1]`);
        const expected5 = [1,0,0,0,0, 0,0,1,0,0, 0,1,0,0,0, 0,0,0,0,1];
        const pass5 = output5.length === 20 && expected5.every((v, i) => Math.abs(output5[i] - v) < 0.01);
        log(`  ${pass5 ? 'PASS ✓' : 'FAIL ✗'}\n`);
        executor5.destroy();
      } catch (e) {
        log(`  FAIL ✗: ${e.message}\n`);
        console.error(e);
      }

      // Test 6: CumSum
      log('Test 6: CumSum (cumulative sum)');
      try {
        const graph6 = Compiler.createGraph();
        const x6 = Compiler.input(graph6, [5], "input");
        const y6 = Compiler.cumsum(graph6, x6, 0);
        Compiler.markOutput(graph6, y6);
        const compiled6 = Compiler.compile(graph6);
        const executor6 = new GraphExecutor(runtime, compiled6);
        await executor6.init();
        
        const input6 = new Float32Array([1, 2, 3, 4, 5]);
        const output6 = await executor6.execute(input6);
        log(`  Input: [${Array.from(input6)}]`);
        log(`  CumSum axis=0`);
        log(`  Output: [${Array.from(output6)}]`);
        log(`  Expected: [1, 3, 6, 10, 15]`);
        const expected6 = [1, 3, 6, 10, 15];
        const pass6 = output6.length === 5 && expected6.every((v, i) => Math.abs(output6[i] - v) < 0.01);
        log(`  ${pass6 ? 'PASS ✓' : 'FAIL ✗'}\n`);
        executor6.destroy();
      } catch (e) {
        log(`  FAIL ✗: ${e.message}\n`);
        console.error(e);
      }

      runtime.destroy();
      log('=== All New Operations Tests Completed ===');
    }
    
    runTests();
  </script>
</body>
</html>
