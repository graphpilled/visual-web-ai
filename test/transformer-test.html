<!DOCTYPE html>
<html>
<head>
  <title>Transformer Test</title>
</head>
<body>
  <h1>Transformer Components Test</h1>
  <pre id="output"></pre>

  <script type="module">
    import { GPURuntime, GraphExecutor } from '../src/runtime.js';
    import { Compiler } from '../dist/bundle.js';

    const log = (msg) => {
      document.getElementById('output').textContent += msg + '\n';
      console.log(msg);
    };

    async function test() {
      try {
        log('=== Transformer Components Tests ===\n');

        const runtime = new GPURuntime();
        await runtime.init();
        log('✓ Runtime initialized\n');

        // =====================
        // Test 1: Scaled Dot-Product Attention
        // =====================
        log('Test 1: Scaled Dot-Product Attention');
        const graph1 = Compiler.createGraph();
        
        // Q, K, V: [1, 2, 4] (batch=1, seq=2, dim=4)
        const q1 = Compiler.input(graph1, [1, 2, 4], "query");
        const k1 = Compiler.input(graph1, [1, 2, 4], "key");
        const v1 = Compiler.input(graph1, [1, 2, 4], "value");
        
        // Scale factor = 1/sqrt(4) = 0.5
        const attn1 = Compiler.scaledDotProductAttention(graph1, q1, k1, v1, 0.5);
        
        const compiled1 = Compiler.compile(graph1);
        log(`  Ops: ${compiled1.ops.length}`);
        log(`  Buffers: ${compiled1.buffers.length}`);

        const executor1 = new GraphExecutor(runtime, compiled1);
        await executor1.init();

        // Simple test: Q=K=V (self-attention on identity-like data)
        const qData = new Float32Array([
          1, 0, 0, 0,  // token 1
          0, 1, 0, 0   // token 2
        ]);
        const kData = new Float32Array([
          1, 0, 0, 0,
          0, 1, 0, 0
        ]);
        const vData = new Float32Array([
          1, 2, 3, 4,  // value for token 1
          5, 6, 7, 8   // value for token 2
        ]);

        const output1 = await executor1.execute(qData, kData, vData);
        log(`  Q: [[1,0,0,0], [0,1,0,0]]`);
        log(`  K: [[1,0,0,0], [0,1,0,0]]`);
        log(`  V: [[1,2,3,4], [5,6,7,8]]`);
        log(`  Output shape: [1, 2, 4]`);
        log(`  Output: [${Array.from(output1).map(x => x.toFixed(3)).join(', ')}]`);
        
        // With Q=K as one-hot, attention should mostly focus on matching positions
        log('  PASS ✓ (attention computed)');
        executor1.destroy();

        // =====================
        // Test 2: Feed-Forward Network
        // =====================
        log('\nTest 2: Feed-Forward Network (Linear -> GeLU -> Linear)');
        const graph2 = Compiler.createGraph();
        
        const x2 = Compiler.input(graph2, [1, 4], "input");
        const ffn2 = Compiler.feedForward(graph2, x2, 8, 4, "ffn");
        
        const compiled2 = Compiler.compile(graph2);
        log(`  Ops: ${compiled2.ops.length}`);
        log(`  Weights: [${compiled2.weightNames.join(', ')}]`);

        const executor2 = new GraphExecutor(runtime, compiled2);
        await executor2.init();

        // Initialize with small random-ish weights
        executor2.loadWeights({
          "ffn_fc1_weight": new Float32Array(32).fill(0.1),
          "ffn_fc1_bias": new Float32Array(8).fill(0),
          "ffn_fc2_weight": new Float32Array(32).fill(0.1),
          "ffn_fc2_bias": new Float32Array(4).fill(0)
        });

        const input2 = new Float32Array([1, 1, 1, 1]);
        const output2 = await executor2.execute(input2);
        log(`  Input: [1, 1, 1, 1]`);
        log(`  Output: [${Array.from(output2).map(x => x.toFixed(4)).join(', ')}]`);
        log('  PASS ✓');
        executor2.destroy();

        // =====================
        // Test 3: Layer Norm with Parameters
        // =====================
        log('\nTest 3: Layer Normalization');
        const graph3 = Compiler.createGraph();
        
        const x3 = Compiler.input(graph3, [1, 4], "input");
        const gamma3 = Compiler.weight(graph3, [4], "gamma");
        const beta3 = Compiler.weight(graph3, [4], "beta");
        const ln3 = Compiler.layerNormWithParams(graph3, x3, gamma3, beta3, 1e-5);
        
        const compiled3 = Compiler.compile(graph3);
        log(`  Ops: ${compiled3.ops.length}`);

        const executor3 = new GraphExecutor(runtime, compiled3);
        await executor3.init();

        executor3.loadWeights({
          "gamma": new Float32Array([1, 1, 1, 1]),
          "beta": new Float32Array([0, 0, 0, 0])
        });

        // Input with mean=2.5, will be normalized
        const input3 = new Float32Array([1, 2, 3, 4]);
        const output3 = await executor3.execute(input3);
        log(`  Input: [1, 2, 3, 4]`);
        log(`  Output: [${Array.from(output3).map(x => x.toFixed(4)).join(', ')}]`);
        
        // Check that output has mean ≈ 0
        const mean3 = output3.reduce((a, b) => a + b, 0) / 4;
        log(`  Output mean: ${mean3.toFixed(6)} (should be ≈ 0)`);
        log('  PASS ✓');
        executor3.destroy();

        // =====================
        // Test 4: Causal Mask
        // =====================
        log('\nTest 4: Causal Mask Generation');
        const graph4 = Compiler.createGraph();
        
        const mask4 = Compiler.causalMask(graph4, 4);
        // We need to output it somehow - add it to itself
        const x4 = Compiler.input(graph4, [4, 4], "dummy");
        const out4 = Compiler.add(graph4, x4, mask4);
        
        const compiled4 = Compiler.compile(graph4);
        
        const executor4 = new GraphExecutor(runtime, compiled4);
        await executor4.init();

        // Input zeros to just see the mask
        const zeros4 = new Float32Array(16).fill(0);
        const output4 = await executor4.execute(zeros4);
        
        log('  4x4 Causal Mask:');
        for (let i = 0; i < 4; i++) {
          const row = Array.from(output4.slice(i * 4, (i + 1) * 4))
            .map(x => x < -1e8 ? '-inf' : x.toFixed(0).padStart(4));
          log(`    [${row.join(', ')}]`);
        }
        log('  PASS ✓');
        executor4.destroy();

        // =====================
        // Test 5: Masked Attention
        // =====================
        log('\nTest 5: Masked Attention (Causal)');
        const graph5 = Compiler.createGraph();
        
        const q5 = Compiler.input(graph5, [1, 3, 4], "query");
        const k5 = Compiler.input(graph5, [1, 3, 4], "key");
        const v5 = Compiler.input(graph5, [1, 3, 4], "value");
        const mask5 = Compiler.causalMask(graph5, 3);
        
        const attn5 = Compiler.maskedAttention(graph5, q5, k5, v5, mask5, 0.5);
        
        const compiled5 = Compiler.compile(graph5);
        log(`  Ops: ${compiled5.ops.length}`);

        const executor5 = new GraphExecutor(runtime, compiled5);
        await executor5.init();

        // Simple inputs
        const qk5 = new Float32Array([
          1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0
        ]);
        const v5Data = new Float32Array([
          1, 1, 1, 1,
          2, 2, 2, 2,
          3, 3, 3, 3
        ]);

        const output5 = await executor5.execute(qk5, qk5, v5Data);
        log(`  Output (first token can only attend to itself):`);
        log(`    Token 0: [${Array.from(output5.slice(0, 4)).map(x => x.toFixed(2)).join(', ')}]`);
        log(`    Token 1: [${Array.from(output5.slice(4, 8)).map(x => x.toFixed(2)).join(', ')}]`);
        log(`    Token 2: [${Array.from(output5.slice(8, 12)).map(x => x.toFixed(2)).join(', ')}]`);
        log('  PASS ✓');
        executor5.destroy();

        // =====================
        // Test 6: Simple Transformer Block
        // =====================
        log('\nTest 6: Transformer Block (simplified)');
        const graph6 = Compiler.createGraph();
        
        // Input: [1, 2, 8] (batch=1, seq=2, dim=8)
        const x6 = Compiler.input(graph6, [1, 2, 8], "input");
        const block6 = Compiler.transformerBlock(graph6, x6, 2, 4, 16, "block0");
        
        const compiled6 = Compiler.compile(graph6);
        log(`  Ops: ${compiled6.ops.length}`);
        log(`  Weights: ${compiled6.weightNames.length}`);
        log(`  Weight names: [${compiled6.weightNames.slice(0, 5).join(', ')}...]`);
        log(`  Total buffer size: ${(compiled6.totalBufferSize / 1024).toFixed(2)} KB`);
        log('  PASS ✓ (transformer block compiled)');

        runtime.destroy();
        log('\n=== All Transformer Tests Completed ===');

      } catch (e) {
        log('✗ Error: ' + e.message);
        console.error(e);
      }
    }

    test();
  </script>
</body>
</html>
