// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as Primitive_int from "@rescript/runtime/lib/es6/Primitive_int.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";

function len(prim) {
  return prim.length;
}

function at(arr, i) {
  return Stdlib_Option.getOr(arr[i], 0);
}

function numElements(shape) {
  return Stdlib_Array.reduce(shape, 1, (a, b) => a * b | 0);
}

function normalizeAxis(axis, rank) {
  if (axis < 0) {
    return rank + axis | 0;
  } else {
    return axis;
  }
}

function broadcast(s1, s2) {
  let r1 = s1.length;
  let r2 = s2.length;
  let maxRank = Primitive_int.max(r1, r2);
  let getDim = (s, r, i) => {
    let offset = maxRank - r | 0;
    if (i < offset) {
      return 1;
    } else {
      return at(s, i - offset | 0);
    }
  };
  let result = Stdlib_Array.fromInitializer(maxRank, i => {
    let d1 = getDim(s1, r1, i);
    let d2 = getDim(s2, r2, i);
    if (d1 === d2) {
      return d1;
    } else if (d1 === 1) {
      return d2;
    } else if (d2 === 1) {
      return d1;
    } else {
      return;
    }
  });
  if (result.every(Stdlib_Option.isSome)) {
    return result.map(__x => Stdlib_Option.getOr(__x, 0));
  }
}

function inferReduce(input, axes, keepDims) {
  let rank = input.length;
  let normAxes = axes.map(a => normalizeAxis(a, rank));
  if (keepDims) {
    return input.map((d, i) => {
      if (normAxes.includes(i)) {
        return 1;
      } else {
        return d;
      }
    });
  } else {
    return input.filter((param, i) => !normAxes.includes(i));
  }
}

function inferMatMul(s1, s2) {
  let r1 = s1.length;
  let r2 = s2.length;
  if (r1 === 0) {
    return;
  }
  if (r1 === 1 && r2 === 1) {
    if (at(s1, 0) === at(s2, 0)) {
      return [1];
    } else {
      return;
    }
  }
  if (r2 === 0) {
    return;
  }
  if (r1 !== 1) {
    if (r2 !== 1) {
      let m = at(s1, r1 - 2 | 0);
      let k1 = at(s1, r1 - 1 | 0);
      let k2 = at(s2, r2 - 2 | 0);
      let n = at(s2, r2 - 1 | 0);
      if (k1 !== k2) {
        return;
      }
      let b1 = s1.slice(0, r1 - 2 | 0);
      let b2 = s2.slice(0, r2 - 2 | 0);
      return Stdlib_Option.map(broadcast(b1, b2), batch => batch.concat([
        m,
        n
      ]));
    }
    let k = at(s1, r1 - 1 | 0);
    if (k === at(s2, 0)) {
      return s1.slice(0, r1 - 1 | 0);
    } else {
      return;
    }
  }
  let k$1 = at(s1, 0);
  let k2$1 = at(s2, r2 - 2 | 0);
  let n$1 = at(s2, r2 - 1 | 0);
  if (k$1 === k2$1) {
    return s2.slice(0, r2 - 2 | 0).concat([n$1]);
  }
}

function inferConv2D(input, filters, param, param$1, padding, param$2) {
  let sW = param$1[1];
  let sH = param$1[0];
  if (input.length !== 4) {
    return;
  }
  let batch = at(input, 0);
  let inH = at(input, 1);
  let inW = at(input, 2);
  let effKH = ((param[0] - 1 | 0) * param$2[0] | 0) + 1 | 0;
  let effKW = ((param[1] - 1 | 0) * param$2[1] | 0) + 1 | 0;
  let match;
  if (typeof padding !== "object") {
    match = padding === "Same" ? [
        Primitive_int.div((inH + sH | 0) - 1 | 0, sH),
        Primitive_int.div((inW + sW | 0) - 1 | 0, sW)
      ] : [
        Primitive_int.div(inH - effKH | 0, sH) + 1 | 0,
        Primitive_int.div(inW - effKW | 0, sW) + 1 | 0
      ];
  } else {
    let pads = padding.pads;
    let p = i => Stdlib_Option.getOr(pads[i], 0);
    match = [
      Primitive_int.div(((inH + p(0) | 0) + p(2) | 0) - effKH | 0, sH) + 1 | 0,
      Primitive_int.div(((inW + p(1) | 0) + p(3) | 0) - effKW | 0, sW) + 1 | 0
    ];
  }
  return [
    batch,
    match[0],
    match[1],
    filters
  ];
}

function inferPool2D(input, param, param$1, padding) {
  let sW = param$1[1];
  let sH = param$1[0];
  let kW = param[1];
  let kH = param[0];
  if (input.length !== 4) {
    return;
  }
  let batch = at(input, 0);
  let inH = at(input, 1);
  let inW = at(input, 2);
  let channels = at(input, 3);
  let match;
  if (typeof padding !== "object") {
    match = padding === "Same" ? [
        Primitive_int.div((inH + sH | 0) - 1 | 0, sH),
        Primitive_int.div((inW + sW | 0) - 1 | 0, sW)
      ] : [
        Primitive_int.div(inH - kH | 0, sH) + 1 | 0,
        Primitive_int.div(inW - kW | 0, sW) + 1 | 0
      ];
  } else {
    let pads = padding.pads;
    let p = i => Stdlib_Option.getOr(pads[i], 0);
    match = [
      Primitive_int.div(((inH + p(0) | 0) + p(2) | 0) - kH | 0, sH) + 1 | 0,
      Primitive_int.div(((inW + p(1) | 0) + p(3) | 0) - kW | 0, sW) + 1 | 0
    ];
  }
  return [
    batch,
    match[0],
    match[1],
    channels
  ];
}

function inferReshape(input, newShape) {
  let total = numElements(input);
  let neg1Count = Stdlib_Array.reduce(newShape, 0, (acc, d) => {
    if (d === -1) {
      return acc + 1 | 0;
    } else {
      return acc;
    }
  });
  if (neg1Count === 0) {
    if (numElements(newShape) === total) {
      return newShape;
    } else {
      return;
    }
  }
  if (neg1Count !== 1) {
    return;
  }
  let known = Stdlib_Array.reduce(newShape, 1, (acc, d) => {
    if (d === -1) {
      return acc;
    } else {
      return acc * d | 0;
    }
  });
  let inferred = Primitive_int.div(total, known);
  if ((inferred * known | 0) === total) {
    return newShape.map(d => {
      if (d === -1) {
        return inferred;
      } else {
        return d;
      }
    });
  }
}

function inferConcat(inputs, axis) {
  if (inputs.length === 0) {
    return;
  }
  let first = Stdlib_Option.getOr(inputs[0], []);
  let rank = first.length;
  let normAxis = normalizeAxis(axis, rank);
  let concatDim = Stdlib_Array.reduce(inputs, 0, (acc, s) => acc + at(s, normAxis) | 0);
  return first.map((d, i) => {
    if (i === normAxis) {
      return concatDim;
    } else {
      return d;
    }
  });
}

function infer(op, inputs) {
  let get = i => Stdlib_Option.getOr(inputs[i], []);
  let input = get(0);
  let r = input.length;
  let exit = 0;
  let kD;
  let kH;
  let kW;
  let sD;
  let sH;
  let sW;
  let padding;
  if (typeof op !== "object") {
    switch (op) {
      case "Add" :
      case "Sub" :
      case "Mul" :
      case "Div" :
      case "Pow" :
      case "Mod" :
      case "FloorDiv" :
      case "Maximum" :
      case "Minimum" :
      case "Atan2" :
      case "Equal" :
      case "NotEqual" :
      case "Greater" :
      case "GreaterEqual" :
      case "Less" :
      case "LessEqual" :
      case "And" :
      case "Or" :
      case "Xor" :
        return broadcast(input, get(1));
      case "Where" :
        return Stdlib_Option.flatMap(broadcast(input, get(1)), s => broadcast(s, get(2)));
      case "MatMul" :
      case "BatchedMatMul" :
        return inferMatMul(input, get(1));
      case "Shape" :
        return [r];
      case "Dot" :
      case "Size" :
      case "Rank" :
        return [1];
      case "GlobalMaxPool" :
      case "GlobalAvgPool" :
        exit = 9;
        break;
      case "NonZero" :
        return;
      default:
        return input;
    }
  } else {
    switch (op.TAG) {
      case "Reduce" :
        return inferReduce(input, op.axes, op.keepDims);
      case "ArgMax" :
      case "ArgMin" :
        exit = 1;
        break;
      case "MatMulInt4" :
        let s2 = get(1);
        let m = at(input, r - 2 | 0);
        let n = at(s2, 0);
        return [
          m,
          n
        ];
      case "Gemm" :
        return inferMatMul(input, get(1));
      case "Reshape" :
        return inferReshape(input, op.newShape);
      case "Squeeze" :
        let axes = op.axes;
        return input.filter((d, i) => !(axes.includes(i) && d === 1));
      case "Unsqueeze" :
        let axes$1 = op.axes;
        let newRank = r + axes$1.length | 0;
        let sortedAxes = axes$1.toSorted(Primitive_int.compare);
        let result = [];
        let inputIdx = 0;
        for (let i = 0; i < newRank; ++i) {
          if (sortedAxes.includes(i)) {
            result = result.concat([1]);
          } else {
            result = result.concat([at(input, inputIdx)]);
            inputIdx = inputIdx + 1 | 0;
          }
        }
        return result;
      case "Flatten" :
        let a = normalizeAxis(op.axis, r);
        return [
          numElements(input.slice(0, a)),
          numElements(input.slice(a, r))
        ];
      case "Transpose" :
        let perm = op.perm;
        if (perm.length === r) {
          return perm.map(p => at(input, p));
        } else {
          return;
        }
      case "Broadcast" :
        return op.targetShape;
      case "ExpandDims" :
        let normAxis = normalizeAxis(op.axis, r + 1 | 0);
        let before = input.slice(0, normAxis);
        let after = input.slice(normAxis, r);
        return before.concat([1]).concat(after);
      case "Slice" :
        let steps = op.steps;
        let ends = op.ends;
        let starts = op.starts;
        let result$1 = input.slice();
        op.axes.forEach((ax, i) => {
          let dimSize = at(input, ax);
          let start = Stdlib_Option.getOr(starts[i], 0);
          let end_ = Stdlib_Option.getOr(ends[i], dimSize);
          let step = Stdlib_Option.getOr(steps[i], 1);
          let s = start < 0 ? dimSize + start | 0 : start;
          let e = end_ < 0 ? dimSize + end_ | 0 : end_;
          let size = Primitive_int.div(((e - s | 0) + step | 0) - 1 | 0, step);
          result$1[ax] = size;
        });
        return result$1;
      case "Gather" :
      case "GatherElements" :
        exit = 2;
        break;
      case "Concat" :
        return inferConcat(inputs, op.axis);
      case "Split" :
        let normAxis$1 = normalizeAxis(op.axis, r);
        let firstSize = Stdlib_Option.getOr(op.splitSizes[0], at(input, normAxis$1));
        return input.map((d, i) => {
          if (i === normAxis$1) {
            return firstSize;
          } else {
            return d;
          }
        });
      case "Stack" :
        let numInputs = inputs.length;
        let normAxis$2 = normalizeAxis(op.axis, r + 1 | 0);
        let before$1 = input.slice(0, normAxis$2);
        let after$1 = input.slice(normAxis$2, r);
        return before$1.concat([numInputs]).concat(after$1);
      case "Tile" :
        let repeats = op.repeats;
        return input.map((d, i) => d * Stdlib_Option.getOr(repeats[i], 1) | 0);
      case "Pad" :
        let pads = op.pads;
        return Stdlib_Array.fromInitializer(r, i => {
          let before = Stdlib_Option.getOr(pads[i], 0);
          let after = Stdlib_Option.getOr(pads[r + i | 0], 0);
          return (at(input, i) + before | 0) + after | 0;
        });
      case "Conv1D" :
        if (r !== 3) {
          return;
        }
        let padding$1 = op.padding;
        let stride = op.stride;
        let batch = at(input, 0);
        let inLen = at(input, 1);
        let effK = ((op.kernel - 1 | 0) * op.dilation | 0) + 1 | 0;
        let outLen;
        if (typeof padding$1 !== "object") {
          outLen = padding$1 === "Same" ? Primitive_int.div((inLen + stride | 0) - 1 | 0, stride) : Primitive_int.div(inLen - effK | 0, stride) + 1 | 0;
        } else {
          let pads$1 = padding$1.pads;
          outLen = Primitive_int.div(((inLen + at(pads$1, 0) | 0) + at(pads$1, 1) | 0) - effK | 0, stride) + 1 | 0;
        }
        return [
          batch,
          outLen,
          op.filters
        ];
      case "Conv2D" :
        return inferConv2D(input, op.filters, op.kernel, op.stride, op.padding, op.dilation);
      case "Conv3D" :
        if (r !== 5) {
          return;
        }
        let match = op.dilation;
        let padding$2 = op.padding;
        let match$1 = op.stride;
        let match$2 = op.kernel;
        let batch$1 = at(input, 0);
        let calc = (inSize, k, s, d) => {
          let effK = ((k - 1 | 0) * d | 0) + 1 | 0;
          if (typeof padding$2 !== "object" && padding$2 === "Same") {
            return Primitive_int.div((inSize + s | 0) - 1 | 0, s);
          }
          return Primitive_int.div(inSize - effK | 0, s) + 1 | 0;
        };
        return [
          batch$1,
          calc(at(input, 1), match$2[0], match$1[0], match[0]),
          calc(at(input, 2), match$2[1], match$1[1], match[1]),
          calc(at(input, 3), match$2[2], match$1[2], match[2]),
          op.filters
        ];
      case "ConvTranspose1D" :
        if (r !== 3) {
          return;
        }
        let stride$1 = op.stride;
        let batch$2 = at(input, 0);
        let inLen$1 = at(input, 1);
        let tmp;
        let exit$1 = 0;
        let tmp$1 = op.padding;
        if (typeof tmp$1 !== "object" && tmp$1 === "Same") {
          tmp = inLen$1 * stride$1 | 0;
        } else {
          exit$1 = 10;
        }
        if (exit$1 === 10) {
          tmp = (inLen$1 * stride$1 | 0) + Primitive_int.max(op.kernel - stride$1 | 0, 0) | 0;
        }
        let outLen$1 = tmp + op.outputPadding | 0;
        return [
          batch$2,
          outLen$1,
          op.filters
        ];
        break;
      case "ConvTranspose2D" :
        if (r !== 4) {
          return;
        }
        let match$3 = op.outputPadding;
        let opW = match$3[1];
        let opH = match$3[0];
        let match$4 = op.stride;
        let sW$1 = match$4[1];
        let sH$1 = match$4[0];
        let match$5 = op.kernel;
        let batch$3 = at(input, 0);
        let inH = at(input, 1);
        let inW = at(input, 2);
        let match$6;
        let exit$2 = 0;
        let tmp$2 = op.padding;
        if (typeof tmp$2 !== "object" && tmp$2 === "Same") {
          match$6 = [
            (inH * sH$1 | 0) + opH | 0,
            (inW * sW$1 | 0) + opW | 0
          ];
        } else {
          exit$2 = 10;
        }
        if (exit$2 === 10) {
          match$6 = [
            ((inH * sH$1 | 0) + Primitive_int.max(match$5[0] - sH$1 | 0, 0) | 0) + opH | 0,
            ((inW * sW$1 | 0) + Primitive_int.max(match$5[1] - sW$1 | 0, 0) | 0) + opW | 0
          ];
        }
        return [
          batch$3,
          match$6[0],
          match$6[1],
          op.filters
        ];
        break;
      case "ConvTranspose3D" :
        if (r !== 5) {
          return;
        }
        let match$7 = op.outputPadding;
        let padding$3 = op.padding;
        let match$8 = op.stride;
        let match$9 = op.kernel;
        let batch$4 = at(input, 0);
        let calc$1 = (inSize, k, s, op) => {
          if (typeof padding$3 !== "object" && padding$3 === "Same") {
            return (inSize * s | 0) + op | 0;
          }
          return ((inSize * s | 0) + Primitive_int.max(k - s | 0, 0) | 0) + op | 0;
        };
        return [
          batch$4,
          calc$1(at(input, 1), match$9[0], match$8[0], match$7[0]),
          calc$1(at(input, 2), match$9[1], match$8[1], match$7[1]),
          calc$1(at(input, 3), match$9[2], match$8[2], match$7[2]),
          op.filters
        ];
      case "DepthwiseConv2D" :
        if (r !== 4) {
          return;
        }
        let match$10 = op.dilation;
        let match$11 = op.stride;
        let sW$2 = match$11[1];
        let sH$2 = match$11[0];
        let match$12 = op.kernel;
        let batch$5 = at(input, 0);
        let inH$1 = at(input, 1);
        let inW$1 = at(input, 2);
        let channels = at(input, 3);
        let effKH = ((match$12[0] - 1 | 0) * match$10[0] | 0) + 1 | 0;
        let effKW = ((match$12[1] - 1 | 0) * match$10[1] | 0) + 1 | 0;
        let match$13;
        let exit$3 = 0;
        let tmp$3 = op.padding;
        if (typeof tmp$3 !== "object" && tmp$3 === "Same") {
          match$13 = [
            Primitive_int.div((inH$1 + sH$2 | 0) - 1 | 0, sH$2),
            Primitive_int.div((inW$1 + sW$2 | 0) - 1 | 0, sW$2)
          ];
        } else {
          exit$3 = 10;
        }
        if (exit$3 === 10) {
          match$13 = [
            Primitive_int.div(inH$1 - effKH | 0, sH$2) + 1 | 0,
            Primitive_int.div(inW$1 - effKW | 0, sW$2) + 1 | 0
          ];
        }
        return [
          batch$5,
          match$13[0],
          match$13[1],
          channels * op.depthMultiplier | 0
        ];
        break;
      case "MaxPool1D" :
        if (r !== 3) {
          return;
        }
        let stride$2 = op.stride;
        let batch$6 = at(input, 0);
        let inLen$2 = at(input, 1);
        let channels$1 = at(input, 2);
        let outLen$2;
        let exit$4 = 0;
        let tmp$4 = op.padding;
        if (typeof tmp$4 !== "object" && tmp$4 === "Same") {
          outLen$2 = Primitive_int.div((inLen$2 + stride$2 | 0) - 1 | 0, stride$2);
        } else {
          exit$4 = 10;
        }
        if (exit$4 === 10) {
          outLen$2 = Primitive_int.div(inLen$2 - op.kernel | 0, stride$2) + 1 | 0;
        }
        return [
          batch$6,
          outLen$2,
          channels$1
        ];
        break;
      case "MaxPool3D" :
        let match$14 = op.stride;
        let match$15 = op.kernel;
        kD = match$15[0];
        kH = match$15[1];
        kW = match$15[2];
        sD = match$14[0];
        sH = match$14[1];
        sW = match$14[2];
        padding = op.padding;
        exit = 8;
        break;
      case "AvgPool1D" :
        if (r !== 3) {
          return;
        }
        let stride$3 = op.stride;
        let batch$7 = at(input, 0);
        let inLen$3 = at(input, 1);
        let channels$2 = at(input, 2);
        let outLen$3;
        let exit$5 = 0;
        let tmp$5 = op.padding;
        if (typeof tmp$5 !== "object" && tmp$5 === "Same") {
          outLen$3 = Primitive_int.div((inLen$3 + stride$3 | 0) - 1 | 0, stride$3);
        } else {
          exit$5 = 10;
        }
        if (exit$5 === 10) {
          outLen$3 = Primitive_int.div(inLen$3 - op.kernel | 0, stride$3) + 1 | 0;
        }
        return [
          batch$7,
          outLen$3,
          channels$2
        ];
        break;
      case "MaxPool2D" :
      case "AvgPool2D" :
        exit = 3;
        break;
      case "AvgPool3D" :
        let match$16 = op.stride;
        let match$17 = op.kernel;
        kD = match$17[0];
        kH = match$17[1];
        kW = match$17[2];
        sD = match$16[0];
        sH = match$16[1];
        sW = match$16[2];
        padding = op.padding;
        exit = 8;
        break;
      case "LpPool" :
        let match$18 = op.stride;
        let match$19 = op.kernel;
        return inferPool2D(input, [
          match$19[0],
          match$19[1]
        ], [
          match$18[0],
          match$18[1]
        ], "Valid");
      case "AdaptiveAvgPool1D" :
      case "AdaptiveMaxPool1D" :
        exit = 4;
        break;
      case "AdaptiveAvgPool2D" :
      case "AdaptiveMaxPool2D" :
        exit = 5;
        break;
      case "Dense" :
        if (r > 0) {
          return input.slice(0, r - 1 | 0).concat([op.units]);
        } else {
          return;
        }
      case "Attention" :
      case "MultiHeadAttention" :
        exit = 6;
        break;
      case "RNN" :
      case "LSTM" :
      case "GRU" :
        exit = 7;
        break;
      case "Resize" :
        let sizes = op.sizes;
        if (sizes !== undefined) {
          if (r === 4) {
            return [
              at(input, 0),
              at(sizes, 0),
              at(sizes, 1),
              at(input, 3)
            ];
          } else {
            return;
          }
        } else {
          return input;
        }
      case "SpaceToDepth" :
        let blockSize = op.blockSize;
        if (r === 4) {
          return [
            at(input, 0),
            Primitive_int.div(at(input, 1), blockSize),
            Primitive_int.div(at(input, 2), blockSize),
            (at(input, 3) * blockSize | 0) * blockSize | 0
          ];
        } else {
          return;
        }
      case "DepthToSpace" :
        let blockSize$1 = op.blockSize;
        if (r === 4) {
          return [
            at(input, 0),
            at(input, 1) * blockSize$1 | 0,
            at(input, 2) * blockSize$1 | 0,
            Primitive_int.div(at(input, 3), blockSize$1 * blockSize$1 | 0)
          ];
        } else {
          return;
        }
      case "GridSample" :
        let grid = get(1);
        if (r === 4 && grid.length === 4) {
          return [
            at(input, 0),
            at(grid, 1),
            at(grid, 2),
            at(input, 3)
          ];
        } else {
          return;
        }
      case "RoiAlign" :
        let rois = get(1);
        if (r === 4 && rois.length === 2) {
          return [
            at(rois, 0),
            op.outputHeight,
            op.outputWidth,
            at(input, 1)
          ];
        } else {
          return;
        }
      case "OneHot" :
        let normAxis$3 = normalizeAxis(op.axis, r + 1 | 0);
        let before$2 = input.slice(0, normAxis$3);
        let after$2 = input.slice(normAxis$3, r);
        return before$2.concat([op.depth]).concat(after$2);
      case "Embedding" :
        return input.concat([op.embeddingDim]);
      case "TopK" :
        let k = op.k;
        let normAxis$4 = normalizeAxis(op.axis, r);
        return input.map((d, i) => {
          if (i === normAxis$4) {
            return k;
          } else {
            return d;
          }
        });
      case "Einsum" :
      case "GatherND" :
      case "NonMaxSuppression" :
      case "Unique" :
        return;
      case "Input" :
      case "Const" :
      case "RandomNormal" :
      case "RandomUniform" :
        return op.shape;
      case "MSELoss" :
      case "CrossEntropyLoss" :
      case "BCELoss" :
      case "BCEWithLogitsLoss" :
      case "NLLLoss" :
      case "CTCLoss" :
      case "HuberLoss" :
      case "SmoothL1Loss" :
      case "TripletMarginLoss" :
      case "CosineEmbeddingLoss" :
        return [1];
      default:
        return input;
    }
  }
  switch (exit) {
    case 1 :
      return inferReduce(input, [op.axis], op.keepDims);
    case 2 :
      let indices = get(1);
      let normAxis$5 = normalizeAxis(op.axis, r);
      let before$3 = input.slice(0, normAxis$5);
      let after$3 = input.slice(normAxis$5 + 1 | 0, r);
      return before$3.concat(indices).concat(after$3);
    case 3 :
      return inferPool2D(input, op.kernel, op.stride, op.padding);
    case 4 :
      if (r === 3) {
        return [
          at(input, 0),
          op.outputSize,
          at(input, 2)
        ];
      } else {
        return;
      }
    case 5 :
      let match$20 = op.outputSize;
      if (r === 4) {
        return [
          at(input, 0),
          match$20[0],
          match$20[1],
          at(input, 3)
        ];
      } else {
        return;
      }
    case 6 :
      if (r >= 2) {
        return [
          at(input, 0),
          at(input, 1),
          op.dim
        ];
      } else {
        return;
      }
    case 7 :
      if (r >= 2) {
        return [
          at(input, 0),
          at(input, 1),
          op.hiddenSize
        ];
      } else {
        return;
      }
    case 8 :
      if (r !== 5) {
        return;
      }
      let batch$8 = at(input, 0);
      let channels$3 = at(input, 4);
      let calc$2 = (inSize, k, s) => {
        if (typeof padding !== "object" && padding === "Same") {
          return Primitive_int.div((inSize + s | 0) - 1 | 0, s);
        }
        return Primitive_int.div(inSize - k | 0, s) + 1 | 0;
      };
      return [
        batch$8,
        calc$2(at(input, 1), kD, sD),
        calc$2(at(input, 2), kH, sH),
        calc$2(at(input, 3), kW, sW),
        channels$3
      ];
    case 9 :
      if (r === 4) {
        return [
          at(input, 0),
          1,
          1,
          at(input, 3)
        ];
      } else {
        return;
      }
  }
}

export {
  len,
  at,
  numElements,
  normalizeAxis,
  broadcast,
  inferReduce,
  inferMatMul,
  inferConv2D,
  inferPool2D,
  inferReshape,
  inferConcat,
  infer,
}
/* No side effect */
