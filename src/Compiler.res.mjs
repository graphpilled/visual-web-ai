// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Shape from "./Shape.res.mjs";
import * as Codegen from "./Codegen.res.mjs";
import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as Primitive_int from "@rescript/runtime/lib/es6/Primitive_int.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as Belt_MutableSetInt from "@rescript/runtime/lib/es6/Belt_MutableSetInt.js";

function mkRef(nodeId) {
  return {
    nodeId: nodeId,
    outputIndex: 0
  };
}

function refOutput(nodeId, outputIndex) {
  return {
    nodeId: nodeId,
    outputIndex: outputIndex
  };
}

function createGraph() {
  return {
    nodes: [],
    nextId: 0,
    outputIds: []
  };
}

function getOpOutputCount(op) {
  if (typeof op !== "object") {
    return 1;
  }
  switch (op.TAG) {
    case "Split" :
      return op.splitSizes.length;
    case "TopK" :
      return 2;
    default:
      return 1;
  }
}

function addNodeInternal(graph, op, inputs, name, kind, data) {
  let id = graph.nextId;
  let inputShapes = inputs.map(inputRef => {
    let inputNode = graph.nodes.find(n => n.id === inputRef.nodeId);
    if (inputNode !== undefined) {
      return Stdlib_Option.getOr(inputNode.outputShapes[inputRef.outputIndex], []);
    } else {
      return [];
    }
  });
  let outputShapes;
  let exit = 0;
  if (typeof op !== "object") {
    exit = 1;
  } else {
    switch (op.TAG) {
      case "Split" :
        let axis = op.axis;
        let inputShape = Stdlib_Option.getOr(inputShapes[0], []);
        outputShapes = op.splitSizes.map(splitSize => inputShape.map((dim, i) => {
          if (i === axis) {
            return splitSize;
          } else {
            return dim;
          }
        }));
        break;
      case "TopK" :
        let axis$1 = op.axis;
        let k = op.k;
        let inputShape$1 = Stdlib_Option.getOr(inputShapes[0], []);
        let outShape = inputShape$1.map((dim, i) => {
          if (i === axis$1 || axis$1 < 0 && i === (inputShape$1.length + axis$1 | 0)) {
            return k;
          } else {
            return dim;
          }
        });
        outputShapes = [
          outShape,
          outShape
        ];
        break;
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    let shape = Shape.infer(op, inputShapes);
    outputShapes = shape !== undefined ? [shape] : [[]];
  }
  let node_dtype = "F32";
  let node = {
    id: id,
    op: op,
    inputs: inputs,
    outputShapes: outputShapes,
    dtype: node_dtype,
    name: name,
    kind: kind,
    data: data
  };
  graph.nodes = graph.nodes.concat([node]);
  graph.nextId = graph.nextId + 1 | 0;
  return id;
}

function addNode(graph, op, inputs, name) {
  let inputRefs = inputs.map(id => ({
    nodeId: id,
    outputIndex: 0
  }));
  return addNodeInternal(graph, op, inputRefs, name, "Intermediate", undefined);
}

function addNodeWithRefs(graph, op, inputs, name) {
  return addNodeInternal(graph, op, inputs, name, "Intermediate", undefined);
}

function input(graph, shape, name) {
  let id = graph.nextId;
  let node_op = {
    TAG: "Input",
    shape: shape,
    dtype: "F32"
  };
  let node_inputs = [];
  let node_outputShapes = [shape];
  let node_dtype = "F32";
  let node_name = name;
  let node = {
    id: id,
    op: node_op,
    inputs: node_inputs,
    outputShapes: node_outputShapes,
    dtype: node_dtype,
    name: node_name,
    kind: "Input",
    data: undefined
  };
  graph.nodes = graph.nodes.concat([node]);
  graph.nextId = graph.nextId + 1 | 0;
  return id;
}

function weight(graph, shape, name) {
  let size = Shape.numElements(shape);
  let zeros = Stdlib_Array.make(size, 0.0);
  let id = graph.nextId;
  let node_op = {
    TAG: "Input",
    shape: shape,
    dtype: "F32"
  };
  let node_inputs = [];
  let node_outputShapes = [shape];
  let node_dtype = "F32";
  let node_name = name;
  let node_data = zeros;
  let node = {
    id: id,
    op: node_op,
    inputs: node_inputs,
    outputShapes: node_outputShapes,
    dtype: node_dtype,
    name: node_name,
    kind: "Weight",
    data: node_data
  };
  graph.nodes = graph.nodes.concat([node]);
  graph.nextId = graph.nextId + 1 | 0;
  return id;
}

function weightWithData(graph, shape, name, data) {
  let id = graph.nextId;
  let node_op = {
    TAG: "Input",
    shape: shape,
    dtype: "F32"
  };
  let node_inputs = [];
  let node_outputShapes = [shape];
  let node_dtype = "F32";
  let node_name = name;
  let node_data = data;
  let node = {
    id: id,
    op: node_op,
    inputs: node_inputs,
    outputShapes: node_outputShapes,
    dtype: node_dtype,
    name: node_name,
    kind: "Weight",
    data: node_data
  };
  graph.nodes = graph.nodes.concat([node]);
  graph.nextId = graph.nextId + 1 | 0;
  return id;
}

function constant(graph, shape, name, data) {
  let id = graph.nextId;
  let node_op = {
    TAG: "Input",
    shape: shape,
    dtype: "F32"
  };
  let node_inputs = [];
  let node_outputShapes = [shape];
  let node_dtype = "F32";
  let node_name = name;
  let node_data = data;
  let node = {
    id: id,
    op: node_op,
    inputs: node_inputs,
    outputShapes: node_outputShapes,
    dtype: node_dtype,
    name: node_name,
    kind: "Constant",
    data: node_data
  };
  graph.nodes = graph.nodes.concat([node]);
  graph.nextId = graph.nextId + 1 | 0;
  return id;
}

function markOutputRef(graph, nodeRef) {
  graph.outputIds = graph.outputIds.concat([nodeRef]);
}

function markOutput(graph, nodeId) {
  markOutputRef(graph, {
    nodeId: nodeId,
    outputIndex: 0
  });
}

function relu(graph, x) {
  return addNode(graph, "ReLU", [x], undefined);
}

function sigmoid(graph, x) {
  return addNode(graph, "Sigmoid", [x], undefined);
}

function tanh_(graph, x) {
  return addNode(graph, "Tanh", [x], undefined);
}

function gelu(graph, x) {
  return addNode(graph, "GeLU", [x], undefined);
}

function silu(graph, x) {
  return addNode(graph, "SiLU", [x], undefined);
}

function neg(graph, x) {
  return addNode(graph, "Neg", [x], undefined);
}

function exp_(graph, x) {
  return addNode(graph, "Exp", [x], undefined);
}

function log_(graph, x) {
  return addNode(graph, "Log", [x], undefined);
}

function sqrt_(graph, x) {
  return addNode(graph, "Sqrt", [x], undefined);
}

function abs_(graph, x) {
  return addNode(graph, "Abs", [x], undefined);
}

function sin_(graph, x) {
  return addNode(graph, "Sin", [x], undefined);
}

function cos_(graph, x) {
  return addNode(graph, "Cos", [x], undefined);
}

function add(graph, a, b) {
  return addNode(graph, "Add", [
    a,
    b
  ], undefined);
}

function sub(graph, a, b) {
  return addNode(graph, "Sub", [
    a,
    b
  ], undefined);
}

function mul(graph, a, b) {
  return addNode(graph, "Mul", [
    a,
    b
  ], undefined);
}

function div(graph, a, b) {
  return addNode(graph, "Div", [
    a,
    b
  ], undefined);
}

function pow_(graph, a, b) {
  return addNode(graph, "Pow", [
    a,
    b
  ], undefined);
}

function maximum(graph, a, b) {
  return addNode(graph, "Maximum", [
    a,
    b
  ], undefined);
}

function minimum(graph, a, b) {
  return addNode(graph, "Minimum", [
    a,
    b
  ], undefined);
}

function matmul(graph, a, b) {
  return addNode(graph, "MatMul", [
    a,
    b
  ], undefined);
}

function denseWithWeights(graph, x, weights, bias) {
  let out = matmul(graph, x, weights);
  if (bias !== undefined) {
    return add(graph, out, bias);
  } else {
    return out;
  }
}

function dense(graph, x, units, name) {
  let inputNode = graph.nodes.find(n => n.id === x);
  let inputShape = inputNode !== undefined ? Stdlib_Option.getOr(inputNode.outputShapes[0], []) : [];
  let inputDim = Stdlib_Option.getOr(inputShape[inputShape.length - 1 | 0], 1);
  let w = weight(graph, [
    inputDim,
    units
  ], name + "_weight");
  let b = weight(graph, [units], name + "_bias");
  return denseWithWeights(graph, x, w, b);
}

function softmax(graph, x, axis) {
  return addNode(graph, {
    TAG: "Softmax",
    axis: axis
  }, [x], undefined);
}

function reduce(graph, x, op, axes, keepDims) {
  return addNode(graph, {
    TAG: "Reduce",
    op: op,
    axes: axes,
    keepDims: keepDims
  }, [x], undefined);
}

function reduceSum(graph, x, axes, keepDims) {
  return reduce(graph, x, "Sum", axes, keepDims);
}

function reduceMean(graph, x, axes, keepDims) {
  return reduce(graph, x, "Mean", axes, keepDims);
}

function reduceMax(graph, x, axes, keepDims) {
  return reduce(graph, x, "Max", axes, keepDims);
}

function conv2dWithWeights(graph, x, weights, bias, stride, padding) {
  let weightsNode = graph.nodes.find(n => n.id === weights);
  let weightsShape = weightsNode !== undefined ? Stdlib_Option.getOr(weightsNode.outputShapes[0], []) : [];
  let filters = Stdlib_Option.getOr(weightsShape[3], 1);
  let kH = Stdlib_Option.getOr(weightsShape[0], 1);
  let kW = Stdlib_Option.getOr(weightsShape[1], 1);
  let conv = addNode(graph, {
    TAG: "Conv2D",
    filters: filters,
    kernel: [
      kH,
      kW
    ],
    stride: stride,
    padding: padding,
    dilation: [
      1,
      1
    ],
    groups: 1
  }, [
    x,
    weights
  ], undefined);
  if (bias !== undefined) {
    return add(graph, conv, bias);
  } else {
    return conv;
  }
}

function conv2d(graph, x, filters, kernelSize, stride, padding, name) {
  let inputNode = graph.nodes.find(n => n.id === x);
  let inputShape = inputNode !== undefined ? Stdlib_Option.getOr(inputNode.outputShapes[0], []) : [];
  let inChannels = Stdlib_Option.getOr(inputShape[3], 1);
  let w = weight(graph, [
    kernelSize,
    kernelSize,
    inChannels,
    filters
  ], name + "_weight");
  let b = weight(graph, [filters], name + "_bias");
  return conv2dWithWeights(graph, x, w, b, [
    stride,
    stride
  ], padding);
}

function maxPool2d(graph, x, size, stride) {
  return addNode(graph, {
    TAG: "MaxPool2D",
    kernel: [
      size,
      size
    ],
    stride: [
      stride,
      stride
    ],
    padding: "Valid"
  }, [x], undefined);
}

function avgPool2d(graph, x, size, stride) {
  return addNode(graph, {
    TAG: "AvgPool2D",
    kernel: [
      size,
      size
    ],
    stride: [
      stride,
      stride
    ],
    padding: "Valid",
    countIncludePad: true
  }, [x], undefined);
}

function globalAvgPool(graph, x) {
  return addNode(graph, "GlobalAvgPool", [x], undefined);
}

function globalMaxPool(graph, x) {
  return addNode(graph, "GlobalMaxPool", [x], undefined);
}

function batchNormWithParams(graph, x, gamma, beta, mean, variance, epsilon) {
  return addNode(graph, {
    TAG: "BatchNorm",
    epsilon: epsilon,
    momentum: 0.1
  }, [
    x,
    gamma,
    beta,
    mean,
    variance
  ], undefined);
}

function layerNorm(graph, x, axes, epsilon) {
  return addNode(graph, {
    TAG: "LayerNorm",
    axes: axes,
    epsilon: epsilon
  }, [x], undefined);
}

function reshape(graph, x, targetShape) {
  return addNode(graph, {
    TAG: "Reshape",
    newShape: targetShape
  }, [x], undefined);
}

function flatten(graph, x) {
  return addNode(graph, {
    TAG: "Flatten",
    axis: 1
  }, [x], undefined);
}

function transpose(graph, x, permutation) {
  return addNode(graph, {
    TAG: "Transpose",
    perm: permutation
  }, [x], undefined);
}

function topk(graph, x, k, axis) {
  let nodeId = addNode(graph, {
    TAG: "TopK",
    k: k,
    axis: axis,
    largest: true,
    sorted: true
  }, [x], undefined);
  return {
    nodeId: nodeId,
    values: {
      nodeId: nodeId,
      outputIndex: 0
    },
    indices: {
      nodeId: nodeId,
      outputIndex: 1
    }
  };
}

function topkValues(graph, x, k, axis) {
  return topk(graph, x, k, axis).nodeId;
}

function split(graph, x, axis, splitSizes) {
  let nodeId = addNode(graph, {
    TAG: "Split",
    axis: axis,
    splitSizes: splitSizes
  }, [x], undefined);
  let outputs = splitSizes.map((param, i) => ({
    nodeId: nodeId,
    outputIndex: i
  }));
  return {
    nodeId: nodeId,
    outputs: outputs
  };
}

function chunk(graph, x, axis, numChunks) {
  let inputNode = graph.nodes.find(n => n.id === x);
  let inputShape = inputNode !== undefined ? Stdlib_Option.getOr(inputNode.outputShapes[0], []) : [];
  let axisSize = Stdlib_Option.getOr(inputShape[axis], numChunks);
  let chunkSize = Primitive_int.div(axisSize, numChunks);
  let splitSizes = Stdlib_Array.make(numChunks, chunkSize);
  return split(graph, x, axis, splitSizes);
}

function where(graph, condition, xTrue, xFalse) {
  return addNode(graph, "Where", [
    condition,
    xTrue,
    xFalse
  ], undefined);
}

function gather(graph, data, indices, axis) {
  return addNode(graph, {
    TAG: "Gather",
    axis: axis
  }, [
    data,
    indices
  ], undefined);
}

function clip(graph, x, minVal, maxVal) {
  return addNode(graph, {
    TAG: "Clip",
    min: minVal,
    max: maxVal
  }, [x], undefined);
}

function clamp(graph, x, minVal, maxVal) {
  return clip(graph, x, minVal, maxVal);
}

function topologicalSort(nodes) {
  let visitedIds = {};
  let resultArr = [];
  let visit = nodeId => {
    let key = nodeId.toString();
    if (!Stdlib_Option.isNone(visitedIds[key])) {
      return;
    }
    visitedIds[key] = true;
    let nodeOpt = nodes.find(n => n.id === nodeId);
    if (nodeOpt !== undefined) {
      nodeOpt.inputs.forEach(inputRef => visit(inputRef.nodeId));
      resultArr.push(nodeOpt);
      return;
    }
  };
  nodes.forEach(node => visit(node.id));
  return resultArr;
}

function allocateBuffers(sortedNodes, outputRefs) {
  let buffers = [];
  let bufferId = {
    contents: 0
  };
  sortedNodes.forEach(node => {
    node.outputShapes.forEach((shape, outputIndex) => {
      let size = (Shape.numElements(shape) << 2);
      let isGraphOutput = outputRefs.some(outRef => {
        if (outRef.nodeId === node.id) {
          return outRef.outputIndex === outputIndex;
        } else {
          return false;
        }
      });
      let kind = isGraphOutput ? "Output" : node.kind;
      let buffer_id = bufferId.contents;
      let buffer_nodeId = node.id;
      let buffer_data = outputIndex === 0 ? node.data : undefined;
      let buffer = {
        id: buffer_id,
        size: size,
        nodeId: buffer_nodeId,
        outputIndex: outputIndex,
        kind: kind,
        data: buffer_data
      };
      buffers.push(buffer);
      bufferId.contents = bufferId.contents + 1 | 0;
    });
  });
  return buffers;
}

function findBufferId(buffers, nodeRef) {
  let buf = buffers.find(b => {
    if (b.nodeId === nodeRef.nodeId) {
      return b.outputIndex === nodeRef.outputIndex;
    } else {
      return false;
    }
  });
  return Stdlib_Option.getOr(Stdlib_Option.map(buf, b => b.id), -1);
}

function compileNode(node, allNodes, buffers) {
  let inputShapes = node.inputs.map(inputRef => {
    let inputNode = allNodes.find(n => n.id === inputRef.nodeId);
    if (inputNode !== undefined) {
      return Stdlib_Option.getOr(inputNode.outputShapes[inputRef.outputIndex], []);
    } else {
      return [];
    }
  });
  let match = node.kind;
  switch (match) {
    case "Intermediate" :
    case "Output" :
      break;
    default:
      return;
  }
  let result = Codegen.generate(node.op, inputShapes);
  return Stdlib_Option.map(result, param => {
    let inputBufferIds = node.inputs.map(inputRef => findBufferId(buffers, inputRef));
    let outputBufferIds = Stdlib_Array.filterMap(node.outputShapes.map((param, i) => i), outputIndex => {
      let buf = buffers.find(b => {
        if (b.nodeId === node.id) {
          return b.outputIndex === outputIndex;
        } else {
          return false;
        }
      });
      return Stdlib_Option.map(buf, b => b.id);
    });
    return {
      nodeId: node.id,
      kernel: param[0],
      dispatch: param[1],
      inputBufferIds: inputBufferIds,
      outputBufferIds: outputBufferIds
    };
  });
}

function compile(graph) {
  let outputRefs;
  if (graph.outputIds.length !== 0) {
    outputRefs = graph.outputIds;
  } else {
    let usedAsInput = Belt_MutableSetInt.make();
    graph.nodes.forEach(node => {
      node.inputs.forEach(inputRef => Belt_MutableSetInt.add(usedAsInput, inputRef.nodeId));
    });
    outputRefs = Stdlib_Array.filterMap(graph.nodes, node => {
      if (!Belt_MutableSetInt.has(usedAsInput, node.id) && node.kind !== "Input" && node.kind !== "Weight" && node.kind !== "Constant") {
        return {
          nodeId: node.id,
          outputIndex: 0
        };
      }
    });
  }
  let sorted = topologicalSort(graph.nodes);
  let buffers = allocateBuffers(sorted, outputRefs);
  let compiledOps = Stdlib_Array.filterMap(sorted, node => compileNode(node, graph.nodes, buffers));
  let inputBufferIds = Stdlib_Array.filterMap(buffers, buf => {
    if (buf.kind === "Input" && buf.outputIndex === 0) {
      return buf.id;
    }
  });
  let weightBufferIds = Stdlib_Array.filterMap(buffers, buf => {
    if (buf.kind === "Weight" && buf.outputIndex === 0) {
      return buf.id;
    }
  });
  let constantBufferIds = Stdlib_Array.filterMap(buffers, buf => {
    if (buf.kind === "Constant" && buf.outputIndex === 0) {
      return buf.id;
    }
  });
  let outputBufferIds = Stdlib_Array.filterMap(buffers, buf => {
    if (buf.kind === "Output") {
      return buf.id;
    }
  });
  let weightNodes = sorted.filter(n => n.kind === "Weight");
  let weightNames = weightNodes.map(n => Stdlib_Option.getOr(n.name, "unnamed"));
  let weightShapes = weightNodes.map(n => Stdlib_Option.getOr(n.outputShapes[0], []));
  let totalBufferSize = Stdlib_Array.reduce(buffers, 0, (acc, buf) => acc + buf.size | 0);
  return {
    buffers: buffers,
    ops: compiledOps,
    inputBufferIds: inputBufferIds,
    weightBufferIds: weightBufferIds,
    constantBufferIds: constantBufferIds,
    outputBufferIds: outputBufferIds,
    totalBufferSize: totalBufferSize,
    weightNames: weightNames,
    weightShapes: weightShapes
  };
}

function compileWithOutputs(graph, outputIds) {
  graph.outputIds = outputIds.map(id => ({
    nodeId: id,
    outputIndex: 0
  }));
  return compile(graph);
}

function scale(graph, x, scalar) {
  let inputNode = graph.nodes.find(n => n.id === x);
  let inputShape = inputNode !== undefined ? Stdlib_Option.getOr(inputNode.outputShapes[0], []) : [];
  let size = Shape.numElements(inputShape);
  let scalarData = Stdlib_Array.make(size, scalar);
  let scalarTensor = constant(graph, inputShape, "scale_const", scalarData);
  return mul(graph, x, scalarTensor);
}

function divByScalar(graph, x, scalar) {
  return scale(graph, x, 1.0 / scalar);
}

function addScalar(graph, x, scalar) {
  let inputNode = graph.nodes.find(n => n.id === x);
  let inputShape = inputNode !== undefined ? Stdlib_Option.getOr(inputNode.outputShapes[0], []) : [];
  let size = Shape.numElements(inputShape);
  let scalarData = Stdlib_Array.make(size, scalar);
  let scalarTensor = constant(graph, inputShape, "add_const", scalarData);
  return add(graph, x, scalarTensor);
}

function embedding(graph, indices, weights) {
  return addNode(graph, {
    TAG: "Embedding",
    numEmbeddings: 0,
    embeddingDim: 0
  }, [
    indices,
    weights
  ], undefined);
}

function layerNormWithParams(graph, x, gamma, beta, epsilon) {
  let inputNode = graph.nodes.find(n => n.id === x);
  let inputShape = inputNode !== undefined ? Stdlib_Option.getOr(inputNode.outputShapes[0], []) : [];
  let lastAxis = inputShape.length - 1 | 0;
  return addNode(graph, {
    TAG: "LayerNorm",
    axes: [lastAxis],
    epsilon: epsilon
  }, [
    x,
    gamma,
    beta
  ], undefined);
}

function concat(graph, inputs, axis) {
  return addNode(graph, {
    TAG: "Concat",
    axis: axis
  }, inputs, undefined);
}

function scaledDotProductAttention(graph, query, key, value, scaleFactor) {
  let keyT = transpose(graph, key, [
    0,
    2,
    1
  ]);
  let scores = matmul(graph, query, keyT);
  let scaledScores = scale(graph, scores, scaleFactor);
  let attnWeights = softmax(graph, scaledScores, -1);
  return matmul(graph, attnWeights, value);
}

function multiHeadAttention(graph, query, key, value, _numHeads, headDim) {
  let scaleFactor = 1.0 / Math.sqrt(headDim);
  return scaledDotProductAttention(graph, query, key, value, scaleFactor);
}

let linear = dense;

function feedForward(graph, x, hiddenDim, outDim, name) {
  let h = linear(graph, x, hiddenDim, name + "_fc1");
  let a = gelu(graph, h);
  return linear(graph, a, outDim, name + "_fc2");
}

function transformerBlock(graph, x, numHeads, headDim, ffnDim, name) {
  let inputNode = graph.nodes.find(n => n.id === x);
  let inputShape = inputNode !== undefined ? Stdlib_Option.getOr(inputNode.outputShapes[0], []) : [];
  let modelDim = Stdlib_Option.getOr(inputShape[inputShape.length - 1 | 0], 64);
  let ln1Gamma = weight(graph, [modelDim], name + "_ln1_gamma");
  let ln1Beta = weight(graph, [modelDim], name + "_ln1_beta");
  let normed1 = layerNormWithParams(graph, x, ln1Gamma, ln1Beta, 1e-5);
  let q = linear(graph, normed1, numHeads * headDim | 0, name + "_q_proj");
  let k = linear(graph, normed1, numHeads * headDim | 0, name + "_k_proj");
  let v = linear(graph, normed1, numHeads * headDim | 0, name + "_v_proj");
  let attnOut = multiHeadAttention(graph, q, k, v, numHeads, headDim);
  let attnProj = linear(graph, attnOut, modelDim, name + "_out_proj");
  let res1 = add(graph, x, attnProj);
  let ln2Gamma = weight(graph, [modelDim], name + "_ln2_gamma");
  let ln2Beta = weight(graph, [modelDim], name + "_ln2_beta");
  let normed2 = layerNormWithParams(graph, res1, ln2Gamma, ln2Beta, 1e-5);
  let ffnOut = feedForward(graph, normed2, ffnDim, modelDim, name + "_ffn");
  return add(graph, res1, ffnOut);
}

function makeCausalMaskData(seqLen) {
  let size = seqLen * seqLen | 0;
  let mask = Stdlib_Array.make(size, 0.0);
  for (let i = 0; i < seqLen; ++i) {
    for (let j = 0; j < seqLen; ++j) {
      let idx = (i * seqLen | 0) + j | 0;
      if (j > i) {
        mask[idx] = -1000000000.0;
      }
    }
  }
  return mask;
}

function causalMask(graph, seqLen) {
  let maskData = makeCausalMaskData(seqLen);
  return constant(graph, [
    seqLen,
    seqLen
  ], "causal_mask", maskData);
}

function maskedAttention(graph, query, key, value, mask, scaleFactor) {
  let keyT = transpose(graph, key, [
    0,
    2,
    1
  ]);
  let scores = matmul(graph, query, keyT);
  let scaledScores = scale(graph, scores, scaleFactor);
  let maskedScores = add(graph, scaledScores, mask);
  let attnWeights = softmax(graph, maskedScores, -1);
  return matmul(graph, attnWeights, value);
}

function sinusoidalPositionalEncoding(graph, seqLen, dim) {
  let posData = Stdlib_Array.fromInitializer(seqLen * dim | 0, i => {
    let pos = Primitive_int.div(i, dim);
    let idx = Primitive_int.mod_(i, dim);
    let divTerm = Math.pow(10000.0, ((idx / 2 | 0) << 1) / dim);
    if (idx % 2 === 0) {
      return Math.sin(pos / divTerm);
    } else {
      return Math.cos(pos / divTerm);
    }
  });
  return constant(graph, [
    seqLen,
    dim
  ], "pos_encoding", posData);
}

function argmax(graph, x, axis) {
  return topk(graph, x, 1, axis);
}

function argmin(graph, x, axis) {
  let node = graph.nodes.find(n => n.id === x);
  let xShape = node !== undefined ? Stdlib_Option.getOr(node.outputShapes[0], []) : [];
  let rank = xShape.length;
  let normAxis = axis < 0 ? rank + axis | 0 : axis;
  return addNode(graph, {
    TAG: "ArgMin",
    axis: normAxis,
    keepDims: false,
    selectLastIndex: false
  }, [x], undefined);
}

function pad(graph, x, pads, constantValue) {
  return addNode(graph, {
    TAG: "Pad",
    pads: pads,
    mode: "Constant",
    constantValue: constantValue
  }, [x], undefined);
}

function tile(graph, x, repeats) {
  return addNode(graph, {
    TAG: "Tile",
    repeats: repeats
  }, [x], undefined);
}

function slice_(graph, x, starts, ends, axes, steps) {
  return addNode(graph, {
    TAG: "Slice",
    starts: starts,
    ends: ends,
    axes: axes,
    steps: steps
  }, [x], undefined);
}

function oneHot(graph, x, depth) {
  return addNode(graph, {
    TAG: "OneHot",
    depth: depth,
    axis: -1
  }, [x], undefined);
}

function scatter(graph, data, indices, updates, axis) {
  return addNode(graph, {
    TAG: "Scatter",
    axis: axis
  }, [
    data,
    indices,
    updates
  ], undefined);
}

function cast(graph, x) {
  return addNode(graph, {
    TAG: "Cast",
    dtype: "F32"
  }, [x], undefined);
}

function cumsum(graph, x, axis) {
  let node = graph.nodes.find(n => n.id === x);
  let xShape = node !== undefined ? Stdlib_Option.getOr(node.outputShapes[0], []) : [];
  let normAxis = axis < 0 ? xShape.length + axis | 0 : axis;
  return addNode(graph, {
    TAG: "CumSum",
    axis: normAxis,
    exclusive: false,
    reverse: false
  }, [x], undefined);
}

function squeeze(graph, x, axes) {
  return addNode(graph, {
    TAG: "Squeeze",
    axes: axes
  }, [x], undefined);
}

function unsqueeze(graph, x, axes) {
  return addNode(graph, {
    TAG: "Unsqueeze",
    axes: axes
  }, [x], undefined);
}

function expandDims(graph, x, axis) {
  return addNode(graph, {
    TAG: "ExpandDims",
    axis: axis
  }, [x], undefined);
}

function broadcast(graph, x, targetShape) {
  return addNode(graph, {
    TAG: "Broadcast",
    targetShape: targetShape
  }, [x], undefined);
}

function stack(graph, inputs, axis) {
  return addNode(graph, {
    TAG: "Stack",
    axis: axis
  }, inputs, undefined);
}

function cumprod(graph, x, axis) {
  let node = graph.nodes.find(n => n.id === x);
  let xShape = node !== undefined ? Stdlib_Option.getOr(node.outputShapes[0], []) : [];
  let normAxis = axis < 0 ? xShape.length + axis | 0 : axis;
  return addNode(graph, {
    TAG: "CumProd",
    axis: normAxis,
    exclusive: false,
    reverse: false
  }, [x], undefined);
}

function reverse(graph, x, axes) {
  return addNode(graph, {
    TAG: "Reverse",
    axes: axes
  }, [x], undefined);
}

function logSoftmax(graph, x, axis) {
  return addNode(graph, {
    TAG: "LogSoftmax",
    axis: axis
  }, [x], undefined);
}

function sort(graph, x, axis, descendingOpt) {
  let descending = descendingOpt !== undefined ? descendingOpt : false;
  return addNode(graph, {
    TAG: "Sort",
    axis: axis,
    descending: descending
  }, [x], undefined);
}

function arange(graph, size, startOpt, stepOpt) {
  let start = startOpt !== undefined ? startOpt : 0.0;
  let step = stepOpt !== undefined ? stepOpt : 1.0;
  let data = Stdlib_Array.fromInitializer(size, i => start + i * step);
  return constant(graph, [size], "arange", data);
}

function lstmCell(graph, x, hPrev, cPrev, hiddenSize, name) {
  let node = graph.nodes.find(n => n.id === x);
  let xShape = node !== undefined ? Stdlib_Option.getOr(node.outputShapes[0], []) : [];
  let inputSize = Stdlib_Option.getOr(xShape[xShape.length - 1 | 0], 1);
  let gateSize = (hiddenSize << 2);
  let wIh = weight(graph, [
    gateSize,
    inputSize
  ], name + "_weight_ih");
  let wHh = weight(graph, [
    gateSize,
    hiddenSize
  ], name + "_weight_hh");
  let bIh = weight(graph, [gateSize], name + "_bias_ih");
  let bHh = weight(graph, [gateSize], name + "_bias_hh");
  let wIhT = transpose(graph, wIh, [
    1,
    0
  ]);
  let wHhT = transpose(graph, wHh, [
    1,
    0
  ]);
  let xW = matmul(graph, x, wIhT);
  let hW = matmul(graph, hPrev, wHhT);
  let gates1 = add(graph, xW, hW);
  let gates2 = add(graph, gates1, bIh);
  let gates = add(graph, gates2, bHh);
  let iGatePre = slice_(graph, gates, [0], [hiddenSize], [1], [1]);
  let fGatePre = slice_(graph, gates, [hiddenSize], [(hiddenSize << 1)], [1], [1]);
  let gGatePre = slice_(graph, gates, [(hiddenSize << 1)], [3 * hiddenSize | 0], [1], [1]);
  let oGatePre = slice_(graph, gates, [3 * hiddenSize | 0], [(hiddenSize << 2)], [1], [1]);
  let iGate = sigmoid(graph, iGatePre);
  let fGate = sigmoid(graph, fGatePre);
  let gGate = tanh_(graph, gGatePre);
  let oGate = sigmoid(graph, oGatePre);
  let fc = mul(graph, fGate, cPrev);
  let ig = mul(graph, iGate, gGate);
  let cNew = add(graph, fc, ig);
  let cTanh = tanh_(graph, cNew);
  let hNew = mul(graph, oGate, cTanh);
  return {
    h: hNew,
    c: cNew
  };
}

function gruCell(graph, x, hPrev, hiddenSize, name) {
  let node = graph.nodes.find(n => n.id === x);
  let xShape = node !== undefined ? Stdlib_Option.getOr(node.outputShapes[0], []) : [];
  let inputSize = Stdlib_Option.getOr(xShape[xShape.length - 1 | 0], 1);
  let gateSize = 3 * hiddenSize | 0;
  let wIh = weight(graph, [
    gateSize,
    inputSize
  ], name + "_weight_ih");
  let wHh = weight(graph, [
    gateSize,
    hiddenSize
  ], name + "_weight_hh");
  let bIh = weight(graph, [gateSize], name + "_bias_ih");
  let bHh = weight(graph, [gateSize], name + "_bias_hh");
  let wIhT = transpose(graph, wIh, [
    1,
    0
  ]);
  let wHhT = transpose(graph, wHh, [
    1,
    0
  ]);
  let xW = matmul(graph, x, wIhT);
  let hW = matmul(graph, hPrev, wHhT);
  let xR = slice_(graph, xW, [0], [hiddenSize], [1], [1]);
  let xZ = slice_(graph, xW, [hiddenSize], [(hiddenSize << 1)], [1], [1]);
  let xN = slice_(graph, xW, [(hiddenSize << 1)], [3 * hiddenSize | 0], [1], [1]);
  let hR = slice_(graph, hW, [0], [hiddenSize], [1], [1]);
  let hZ = slice_(graph, hW, [hiddenSize], [(hiddenSize << 1)], [1], [1]);
  let hN = slice_(graph, hW, [(hiddenSize << 1)], [3 * hiddenSize | 0], [1], [1]);
  let bIhR = slice_(graph, bIh, [0], [hiddenSize], [0], [1]);
  let bIhZ = slice_(graph, bIh, [hiddenSize], [(hiddenSize << 1)], [0], [1]);
  let bIhN = slice_(graph, bIh, [(hiddenSize << 1)], [3 * hiddenSize | 0], [0], [1]);
  let bHhR = slice_(graph, bHh, [0], [hiddenSize], [0], [1]);
  let bHhZ = slice_(graph, bHh, [hiddenSize], [(hiddenSize << 1)], [0], [1]);
  let bHhN = slice_(graph, bHh, [(hiddenSize << 1)], [3 * hiddenSize | 0], [0], [1]);
  let rPre1 = add(graph, xR, hR);
  let rPre2 = add(graph, rPre1, bIhR);
  let rPre3 = add(graph, rPre2, bHhR);
  let rGate = sigmoid(graph, rPre3);
  let zPre1 = add(graph, xZ, hZ);
  let zPre2 = add(graph, zPre1, bIhZ);
  let zPre3 = add(graph, zPre2, bHhZ);
  let zGate = sigmoid(graph, zPre3);
  let hNBias = add(graph, hN, bHhN);
  let rH = mul(graph, rGate, hNBias);
  let nPre1 = add(graph, xN, bIhN);
  let nPre2 = add(graph, nPre1, rH);
  let nGate = tanh_(graph, nPre2);
  let ones = constant(graph, [hiddenSize], "ones", Stdlib_Array.fromInitializer(hiddenSize, param => 1.0));
  let oneMinusZ = sub(graph, ones, zGate);
  let term1 = mul(graph, oneMinusZ, nGate);
  let term2 = mul(graph, zGate, hPrev);
  return add(graph, term1, term2);
}

function lstm(graph, x, hiddenSize, name) {
  let node = graph.nodes.find(n => n.id === x);
  let xShape = node !== undefined ? Stdlib_Option.getOr(node.outputShapes[0], []) : [];
  let batchSize = Stdlib_Option.getOr(xShape[0], 1);
  let seqLen = Stdlib_Option.getOr(xShape[1], 1);
  let inputSize = Stdlib_Option.getOr(xShape[2], 1);
  let h0 = constant(graph, [
    batchSize,
    hiddenSize
  ], name + "_h0", Stdlib_Array.fromInitializer(batchSize * hiddenSize | 0, param => 0.0));
  let c0 = constant(graph, [
    batchSize,
    hiddenSize
  ], name + "_c0", Stdlib_Array.fromInitializer(batchSize * hiddenSize | 0, param => 0.0));
  let outputs = [];
  let h = h0;
  let c = c0;
  for (let t = 0; t < seqLen; ++t) {
    let xt = slice_(graph, x, [
      0,
      t,
      0
    ], [
      batchSize,
      t + 1 | 0,
      inputSize
    ], [
      0,
      1,
      2
    ], [
      1,
      1,
      1
    ]);
    let xtFlat = reshape(graph, xt, [
      batchSize,
      inputSize
    ]);
    let result = lstmCell(graph, xtFlat, h, c, hiddenSize, name + "_t" + t.toString());
    h = result.h;
    c = result.c;
    let hExp = reshape(graph, result.h, [
      batchSize,
      1,
      hiddenSize
    ]);
    outputs = outputs.concat([hExp]);
  }
  if (outputs.length === 1) {
    return Stdlib_Option.getOr(outputs[0], h0);
  }
  let result$1 = Stdlib_Option.getOr(outputs[0], h0);
  for (let i = 1, i_finish = outputs.length; i < i_finish; ++i) {
    result$1 = concat(graph, [
      result$1,
      Stdlib_Option.getOr(outputs[i], h0)
    ], 1);
  }
  return result$1;
}

function gru(graph, x, hiddenSize, name) {
  let node = graph.nodes.find(n => n.id === x);
  let xShape = node !== undefined ? Stdlib_Option.getOr(node.outputShapes[0], []) : [];
  let batchSize = Stdlib_Option.getOr(xShape[0], 1);
  let seqLen = Stdlib_Option.getOr(xShape[1], 1);
  let inputSize = Stdlib_Option.getOr(xShape[2], 1);
  let h0 = constant(graph, [
    batchSize,
    hiddenSize
  ], name + "_h0", Stdlib_Array.fromInitializer(batchSize * hiddenSize | 0, param => 0.0));
  let outputs = [];
  let h = h0;
  for (let t = 0; t < seqLen; ++t) {
    let xt = slice_(graph, x, [
      0,
      t,
      0
    ], [
      batchSize,
      t + 1 | 0,
      inputSize
    ], [
      0,
      1,
      2
    ], [
      1,
      1,
      1
    ]);
    let xtFlat = reshape(graph, xt, [
      batchSize,
      inputSize
    ]);
    let hNew = gruCell(graph, xtFlat, h, hiddenSize, name + "_t" + t.toString());
    h = hNew;
    let hExp = reshape(graph, hNew, [
      batchSize,
      1,
      hiddenSize
    ]);
    outputs = outputs.concat([hExp]);
  }
  if (outputs.length === 1) {
    return Stdlib_Option.getOr(outputs[0], h0);
  }
  let result = Stdlib_Option.getOr(outputs[0], h0);
  for (let i = 1, i_finish = outputs.length; i < i_finish; ++i) {
    result = concat(graph, [
      result,
      Stdlib_Option.getOr(outputs[i], h0)
    ], 1);
  }
  return result;
}

function tensorKindToString(kind) {
  switch (kind) {
    case "Input" :
      return "Input";
    case "Weight" :
      return "Weight";
    case "Constant" :
      return "Constant";
    case "Intermediate" :
      return "Intermediate";
    case "Output" :
      return "Output";
  }
}

function printGraph(graph) {
  console.log("=== Computation Graph ===");
  console.log("Nodes: " + graph.nodes.length.toString());
  graph.nodes.forEach(node => {
    let name = Stdlib_Option.getOr(node.name, "unnamed");
    let kind = tensorKindToString(node.kind);
    let shapesStr = node.outputShapes.map(s => "[" + s.map(d => d.toString()).join(", ") + "]").join(", ");
    let inputsStr = "[" + node.inputs.map(r => r.nodeId.toString() + ":" + r.outputIndex.toString()).join(", ") + "]";
    console.log("  Node " + node.id.toString() + " (" + kind + "): " + name + " outputs=" + shapesStr + " inputs=" + inputsStr);
  });
}

function printCompiled(compiled) {
  console.log("\n=== Compiled Graph ===");
  console.log("Buffers: " + compiled.buffers.length.toString());
  console.log("Ops: " + compiled.ops.length.toString());
  console.log("Total buffer size: " + compiled.totalBufferSize.toString() + " bytes");
  console.log("\nInputs: [" + compiled.inputBufferIds.map(i => i.toString()).join(", ") + "]");
  console.log("Weights: [" + compiled.weightBufferIds.map(i => i.toString()).join(", ") + "]");
  console.log("Constants: [" + compiled.constantBufferIds.map(i => i.toString()).join(", ") + "]");
  console.log("Outputs: [" + compiled.outputBufferIds.map(i => i.toString()).join(", ") + "]");
  console.log("\nWeight names: [" + compiled.weightNames.join(", ") + "]");
  console.log("\nOps:");
  compiled.ops.forEach(op => {
    let inputsStr = "[" + op.inputBufferIds.map(i => i.toString()).join(", ") + "]";
    let outputsStr = "[" + op.outputBufferIds.map(i => i.toString()).join(", ") + "]";
    console.log("  " + op.kernel.name + ": inputs=" + inputsStr + " outputs=" + outputsStr);
  });
}

export {
  mkRef,
  refOutput,
  createGraph,
  getOpOutputCount,
  addNodeInternal,
  addNode,
  addNodeWithRefs,
  input,
  weight,
  weightWithData,
  constant,
  markOutputRef,
  markOutput,
  relu,
  sigmoid,
  tanh_,
  gelu,
  silu,
  neg,
  exp_,
  log_,
  sqrt_,
  abs_,
  sin_,
  cos_,
  add,
  sub,
  mul,
  div,
  pow_,
  maximum,
  minimum,
  matmul,
  denseWithWeights,
  dense,
  softmax,
  reduce,
  reduceSum,
  reduceMean,
  reduceMax,
  conv2dWithWeights,
  conv2d,
  maxPool2d,
  avgPool2d,
  globalAvgPool,
  globalMaxPool,
  batchNormWithParams,
  layerNorm,
  reshape,
  flatten,
  transpose,
  topk,
  topkValues,
  split,
  chunk,
  where,
  gather,
  clip,
  clamp,
  topologicalSort,
  allocateBuffers,
  findBufferId,
  compileNode,
  compile,
  compileWithOutputs,
  scale,
  divByScalar,
  addScalar,
  embedding,
  layerNormWithParams,
  concat,
  scaledDotProductAttention,
  multiHeadAttention,
  linear,
  feedForward,
  transformerBlock,
  makeCausalMaskData,
  causalMask,
  maskedAttention,
  sinusoidalPositionalEncoding,
  argmax,
  argmin,
  pad,
  tile,
  slice_,
  oneHot,
  scatter,
  cast,
  cumsum,
  squeeze,
  unsqueeze,
  expandDims,
  broadcast,
  stack,
  cumprod,
  reverse,
  logSoftmax,
  sort,
  arange,
  lstmCell,
  gruCell,
  lstm,
  gru,
  tensorKindToString,
  printGraph,
  printCompiled,
}
/* Codegen Not a pure module */
