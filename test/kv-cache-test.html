<!DOCTYPE html>
<html>
<head>
  <title>KV Cache Test</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #1a1a2e; color: #eee; }
    pre { background: #16213e; padding: 15px; border-radius: 8px; overflow-x: auto; }
    .pass { color: #4ade80; }
    .fail { color: #f87171; }
    .header { color: #c084fc; font-weight: bold; }
    .info { color: #60a5fa; }
    button { 
      padding: 10px 20px; 
      font-size: 16px; 
      margin: 10px 5px;
      cursor: pointer;
      background: #4f46e5;
      color: white;
      border: none;
      border-radius: 5px;
    }
    button:hover { background: #6366f1; }
  </style>
</head>
<body>
  <h1> KV Cache Test</h1>
  <p>Tests KV Cache for Qwen2.5 autoregressive generation.</p>
  <button onclick="runTests()">Run All Tests</button>
  <pre id="output"></pre>

  <script src="kv-cache.js"></script>
  <script>
    let device = null;
    
    const log = (msg, cls = '') => {
      const output = document.getElementById('output');
      const span = cls ? `<span class="${cls}">${msg}</span>` : msg;
      output.innerHTML += span + '\n';
      output.scrollTop = output.scrollHeight;
    };
    
    const clear = () => {
      document.getElementById('output').innerHTML = '';
    };

    // Qwen2.5-7B config
    const CONFIG = {
      numLayers: 28,
      numKVHeads: 4,
      headDim: 128,
      maxSeqLen: 2048
    };

    async function initWebGPU() {
      if (device) return device;
      
      if (!navigator.gpu) {
        throw new Error('WebGPU not supported');
      }
      
      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) {
        throw new Error('No GPU adapter found');
      }
      
      device = await adapter.requestDevice({
        requiredLimits: {
          maxStorageBufferBindingSize: 512 * 1024 * 1024,
        }
      });
      log(' WebGPU initialized', 'pass');
      return device;
    }

    async function readBuffer(buffer, size) {
      const readBuffer = device.createBuffer({
        size: size,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
      });
      
      const commandEncoder = device.createCommandEncoder();
      commandEncoder.copyBufferToBuffer(buffer, 0, readBuffer, 0, size);
      device.queue.submit([commandEncoder.finish()]);
      
      await readBuffer.mapAsync(GPUMapMode.READ);
      const data = new Float32Array(readBuffer.getMappedRange().slice(0));
      readBuffer.unmap();
      readBuffer.destroy();
      
      return data;
    }

    async function runTests() {
      clear();
      log('=== KV Cache Tests ===\n', 'header');
      
      try {
        await initWebGPU();
        
        log(`\nQwen2.5-7B Config:`, 'info');
        log(`  Layers: ${CONFIG.numLayers}`);
        log(`  KV heads: ${CONFIG.numKVHeads}`);
        log(`  Head dim: ${CONFIG.headDim}`);
        log(`  Max seq len: ${CONFIG.maxSeqLen}`);
        
        // Test 1: Initialize KV Cache
        log('\n--- Test 1: Initialize KV Cache ---', 'header');
        
        const kvCache = new KVCache(device, CONFIG);
        
        const memoryMB = kvCache.getMemoryUsage() / 1024 / 1024;
        log(`  Memory allocated: ${memoryMB.toFixed(1)} MB`);
        log(`  Initial seq_len: ${kvCache.getSeqLen()}`);
        log(`   KV Cache initialized`, 'pass');
        
        // Test 2: Append single K/V
        log('\n--- Test 2: Append Single K/V ---', 'header');
        
        const kvSize = CONFIG.numKVHeads * CONFIG.headDim;
        const testK = new Float32Array(kvSize);
        const testV = new Float32Array(kvSize);
        
        // Fill with recognizable pattern
        for (let i = 0; i < kvSize; i++) {
          testK[i] = i * 0.01;
          testV[i] = i * 0.02 + 1.0;
        }
        
        // Append to layer 0
        kvCache.appendFromCPU(0, testK, testV);
        kvCache.incrementSeqLen();
        
        log(`  Appended K/V to layer 0`);
        log(`  seq_len after: ${kvCache.getSeqLen()}`);
        
        // Read back and verify
        const kData = await readBuffer(kvCache.kCacheBuffers[0], kvSize * 4);
        const vData = await readBuffer(kvCache.vCacheBuffers[0], kvSize * 4);
        
        let kMatch = true, vMatch = true;
        for (let i = 0; i < kvSize; i++) {
          if (Math.abs(kData[i] - testK[i]) > 1e-6) kMatch = false;
          if (Math.abs(vData[i] - testV[i]) > 1e-6) vMatch = false;
        }
        
        log(`  K data match: ${kMatch ? '' : ''}`, kMatch ? 'pass' : 'fail');
        log(`  V data match: ${vMatch ? '' : ''}`, vMatch ? 'pass' : 'fail');
        
        // Test 3: Append multiple tokens
        log('\n--- Test 3: Append Multiple Tokens ---', 'header');
        
        const numTokens = 10;
        for (let t = 1; t < numTokens; t++) {
          const k = new Float32Array(kvSize);
          const v = new Float32Array(kvSize);
          for (let i = 0; i < kvSize; i++) {
            k[i] = t + i * 0.001;
            v[i] = t * 10 + i * 0.001;
          }
          kvCache.appendFromCPU(0, k, v);
          kvCache.incrementSeqLen();
        }
        
        log(`  Appended ${numTokens - 1} more tokens`);
        log(`  seq_len: ${kvCache.getSeqLen()}`);
        
        // Verify last token
        const fullKData = await readBuffer(kvCache.kCacheBuffers[0], kvSize * numTokens * 4);
        const lastTokenOffset = (numTokens - 1) * kvSize;
        const lastK = fullKData[lastTokenOffset];
        const expectedLastK = (numTokens - 1) + 0 * 0.001;
        
        const lastMatch = Math.abs(lastK - expectedLastK) < 1e-5;
        log(`  Last token K[0]: ${lastK.toFixed(4)} (expected: ${expectedLastK.toFixed(4)})`);
        log(`  ${lastMatch ? ' PASS' : ' FAIL'}`, lastMatch ? 'pass' : 'fail');
        
        // Test 4: Multi-layer append
        log('\n--- Test 4: Multi-Layer Append ---', 'header');
        
        kvCache.reset();
        log(`  Reset cache, seq_len: ${kvCache.getSeqLen()}`);
        
        // Append to all layers
        for (let layer = 0; layer < CONFIG.numLayers; layer++) {
          const k = new Float32Array(kvSize).fill(layer + 0.1);
          const v = new Float32Array(kvSize).fill(layer + 0.2);
          kvCache.appendFromCPU(layer, k, v);
        }
        kvCache.incrementSeqLen();
        
        log(`  Appended to all ${CONFIG.numLayers} layers`);
        
        // Verify a few layers
        const layer0K = await readBuffer(kvCache.kCacheBuffers[0], 4);
        const layer14K = await readBuffer(kvCache.kCacheBuffers[14], 4);
        const layer27K = await readBuffer(kvCache.kCacheBuffers[27], 4);
        
        log(`  Layer 0 K[0]: ${layer0K[0].toFixed(2)} (expected: 0.10)`);
        log(`  Layer 14 K[0]: ${layer14K[0].toFixed(2)} (expected: 14.10)`);
        log(`  Layer 27 K[0]: ${layer27K[0].toFixed(2)} (expected: 27.10)`);
        
        const multiLayerMatch = 
          Math.abs(layer0K[0] - 0.1) < 0.01 &&
          Math.abs(layer14K[0] - 14.1) < 0.01 &&
          Math.abs(layer27K[0] - 27.1) < 0.01;
        
        log(`  ${multiLayerMatch ? ' PASS' : ' FAIL'}`, multiLayerMatch ? 'pass' : 'fail');
        
        // Test 5: Sequence length buffer
        log('\n--- Test 5: Sequence Length Buffer ---', 'header');
        
        kvCache.reset();
        for (let i = 0; i < 5; i++) {
          const k = new Float32Array(kvSize);
          const v = new Float32Array(kvSize);
          kvCache.appendFromCPU(0, k, v);
          kvCache.incrementSeqLen();
        }
        
        // Read seq_len buffer
        const seqLenRead = device.createBuffer({
          size: 4,
          usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
        });
        const cmd = device.createCommandEncoder();
        cmd.copyBufferToBuffer(kvCache.seqLenBuffer, 0, seqLenRead, 0, 4);
        device.queue.submit([cmd.finish()]);
        
        await seqLenRead.mapAsync(GPUMapMode.READ);
        const seqLenValue = new Uint32Array(seqLenRead.getMappedRange())[0];
        seqLenRead.unmap();
        seqLenRead.destroy();
        
        log(`  seq_len buffer value: ${seqLenValue} (expected: 5)`);
        log(`  ${seqLenValue === 5 ? ' PASS' : ' FAIL'}`, seqLenValue === 5 ? 'pass' : 'fail');
        
        // Test 6: Memory estimate
        log('\n--- Test 6: Memory Analysis ---', 'header');
        
        const perLayerMB = CONFIG.maxSeqLen * CONFIG.numKVHeads * CONFIG.headDim * 4 * 2 / 1024 / 1024;
        const totalMB = perLayerMB * CONFIG.numLayers;
        
        log(`  Per layer (K+V): ${perLayerMB.toFixed(2)} MB`);
        log(`  Total (28 layers): ${totalMB.toFixed(1)} MB`);
        log(`  Per 1K tokens: ${(totalMB / CONFIG.maxSeqLen * 1000).toFixed(1)} MB`);
        
        // Cleanup
        kvCache.destroy();
        
        log('\n All tests complete!', 'pass');
        
      } catch (e) {
        log(`\n Error: ${e.message}`, 'fail');
        console.error(e);
      }
    }
  </script>
</body>
</html>
