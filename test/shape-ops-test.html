<!DOCTYPE html>
<html>
<head>
  <title>Shape Operations Test (Squeeze, Unsqueeze, Broadcast, Stack)</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #1a1a2e; color: #eee; }
    pre { background: #16213e; padding: 15px; border-radius: 8px; overflow-x: auto; }
  </style>
</head>
<body>
  <h1>Shape Operations Test</h1>
  <pre id="output"></pre>
  <script type="module">
    import { GPURuntime, GraphExecutor } from '../src/runtime.js';
    import { Compiler } from '../dist/bundle.js';
    
    const log = (msg) => {
      document.getElementById('output').textContent += msg + '\n';
      console.log(msg);
    };
    
    async function runTests() {
      log('=== Shape Operations Tests ===\n');
      
      const runtime = new GPURuntime();
      await runtime.init();
      log(' Runtime initialized\n');

      // Test 1: Squeeze
      log('Test 1: Squeeze (remove size-1 dimensions)');
      try {
        const graph1 = Compiler.createGraph();
        const x1 = Compiler.input(graph1, [1, 4, 1], "input");  // shape [1, 4, 1]
        const y1 = Compiler.squeeze(graph1, x1, [0, 2]);  // remove dims 0 and 2
        Compiler.markOutput(graph1, y1);
        const compiled1 = Compiler.compile(graph1);
        const executor1 = new GraphExecutor(runtime, compiled1);
        await executor1.init();
        
        const input1 = new Float32Array([1, 2, 3, 4]);
        const output1 = await executor1.execute(input1);
        log(`  Input shape: [1, 4, 1]`);
        log(`  Squeeze axes [0, 2]`);
        log(`  Output: [${Array.from(output1)}]`);
        log(`  Expected: [1, 2, 3, 4] (shape [4])`);
        const pass1 = output1.length === 4 && [1,2,3,4].every((v,i) => output1[i] === v);
        log(`  ${pass1 ? 'PASS ' : 'FAIL '}\n`);
        executor1.destroy();
      } catch (e) {
        log(`  FAIL : ${e.message}\n`);
        console.error(e);
      }

      // Test 2: Unsqueeze
      log('Test 2: Unsqueeze (add size-1 dimensions)');
      try {
        const graph2 = Compiler.createGraph();
        const x2 = Compiler.input(graph2, [4], "input");  // shape [4]
        const y2 = Compiler.unsqueeze(graph2, x2, [0, 2]);  // add dims at 0 and 2
        Compiler.markOutput(graph2, y2);
        const compiled2 = Compiler.compile(graph2);
        const executor2 = new GraphExecutor(runtime, compiled2);
        await executor2.init();
        
        const input2 = new Float32Array([1, 2, 3, 4]);
        const output2 = await executor2.execute(input2);
        log(`  Input shape: [4]`);
        log(`  Unsqueeze axes [0, 2]`);
        log(`  Output: [${Array.from(output2)}]`);
        log(`  Expected: [1, 2, 3, 4] (shape [1, 4, 1])`);
        const pass2 = output2.length === 4 && [1,2,3,4].every((v,i) => output2[i] === v);
        log(`  ${pass2 ? 'PASS ' : 'FAIL '}\n`);
        executor2.destroy();
      } catch (e) {
        log(`  FAIL : ${e.message}\n`);
        console.error(e);
      }

      // Test 3: ExpandDims
      log('Test 3: ExpandDims (add single dimension)');
      try {
        const graph3 = Compiler.createGraph();
        const x3 = Compiler.input(graph3, [2, 3], "input");  // shape [2, 3]
        const y3 = Compiler.expandDims(graph3, x3, 1);  // add dim at axis 1 -> [2, 1, 3]
        Compiler.markOutput(graph3, y3);
        const compiled3 = Compiler.compile(graph3);
        const executor3 = new GraphExecutor(runtime, compiled3);
        await executor3.init();
        
        const input3 = new Float32Array([1, 2, 3, 4, 5, 6]);
        const output3 = await executor3.execute(input3);
        log(`  Input shape: [2, 3]`);
        log(`  ExpandDims axis=1`);
        log(`  Output: [${Array.from(output3)}]`);
        log(`  Expected: [1, 2, 3, 4, 5, 6] (shape [2, 1, 3])`);
        const pass3 = output3.length === 6 && [1,2,3,4,5,6].every((v,i) => output3[i] === v);
        log(`  ${pass3 ? 'PASS ' : 'FAIL '}\n`);
        executor3.destroy();
      } catch (e) {
        log(`  FAIL : ${e.message}\n`);
        console.error(e);
      }

      // Test 4: Broadcast
      log('Test 4: Broadcast (expand to target shape)');
      try {
        const graph4 = Compiler.createGraph();
        const x4 = Compiler.input(graph4, [1, 3], "input");  // shape [1, 3]
        const y4 = Compiler.broadcast(graph4, x4, [4, 3]);  // broadcast to [4, 3]
        Compiler.markOutput(graph4, y4);
        const compiled4 = Compiler.compile(graph4);
        const executor4 = new GraphExecutor(runtime, compiled4);
        await executor4.init();
        
        const input4 = new Float32Array([1, 2, 3]);
        const output4 = await executor4.execute(input4);
        log(`  Input shape: [1, 3], values: [1, 2, 3]`);
        log(`  Broadcast to [4, 3]`);
        log(`  Output: [${Array.from(output4)}]`);
        log(`  Expected: [1,2,3, 1,2,3, 1,2,3, 1,2,3] (repeated 4 times)`);
        const expected4 = [1,2,3, 1,2,3, 1,2,3, 1,2,3];
        const pass4 = output4.length === 12 && expected4.every((v,i) => Math.abs(output4[i] - v) < 0.01);
        log(`  ${pass4 ? 'PASS ' : 'FAIL '}\n`);
        executor4.destroy();
      } catch (e) {
        log(`  FAIL : ${e.message}\n`);
        console.error(e);
      }

      // Test 5: Stack (simplified - single input for now)
      log('Test 5: Stack operation check');
      try {
        const graph5 = Compiler.createGraph();
        const x5 = Compiler.input(graph5, [3], "input");
        // For now just verify it compiles - full stack needs multiple inputs
        const y5 = Compiler.stack(graph5, [x5], 0);
        Compiler.markOutput(graph5, y5);
        const compiled5 = Compiler.compile(graph5);
        log(`  Stack compiles successfully`);
        log(`  PASS \n`);
      } catch (e) {
        log(`  FAIL : ${e.message}\n`);
        console.error(e);
      }

      runtime.destroy();
      log('=== All Shape Operations Tests Completed ===');
    }
    
    runTests();
  </script>
</body>
</html>
