<!DOCTYPE html>
<html>
<head>
  <title>Extra Operations Test (LogSoftmax, Sort, Arange)</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #1a1a2e; color: #eee; }
    pre { background: #16213e; padding: 15px; border-radius: 8px; overflow-x: auto; }
  </style>
</head>
<body>
  <h1>Extra Operations Test</h1>
  <pre id="output"></pre>
  <script type="module">
    import { GPURuntime, GraphExecutor } from '../src/runtime.js';
    import { Compiler } from '../dist/bundle.js';
    
    const log = (msg) => {
      document.getElementById('output').textContent += msg + '\n';
      console.log(msg);
    };
    
    async function runTests() {
      log('=== Extra Operations Tests ===\n');
      
      const runtime = new GPURuntime();
      await runtime.init();
      log(' Runtime initialized\n');

      // Test 1: LogSoftmax
      log('Test 1: LogSoftmax');
      try {
        const graph1 = Compiler.createGraph();
        const x1 = Compiler.input(graph1, [2, 4], "input");
        const y1 = Compiler.logSoftmax(graph1, x1, -1);  // along last axis
        Compiler.markOutput(graph1, y1);
        const compiled1 = Compiler.compile(graph1);
        const executor1 = new GraphExecutor(runtime, compiled1);
        await executor1.init();
        
        const input1 = new Float32Array([1, 2, 3, 4, 1, 1, 1, 1]);
        const output1 = await executor1.execute(input1);
        log(`  Input: [[1,2,3,4], [1,1,1,1]]`);
        log(`  LogSoftmax: [${Array.from(output1).map(v => v.toFixed(4)).join(', ')}]`);
        
        // Verify: exp(output) should sum to 1 for each row
        const row1Sum = Math.exp(output1[0]) + Math.exp(output1[1]) + Math.exp(output1[2]) + Math.exp(output1[3]);
        const row2Sum = Math.exp(output1[4]) + Math.exp(output1[5]) + Math.exp(output1[6]) + Math.exp(output1[7]);
        log(`  exp(logSoftmax) sums: row1=${row1Sum.toFixed(4)}, row2=${row2Sum.toFixed(4)}`);
        const pass1 = Math.abs(row1Sum - 1.0) < 0.01 && Math.abs(row2Sum - 1.0) < 0.01;
        log(`  ${pass1 ? 'PASS ' : 'FAIL '}\n`);
        executor1.destroy();
      } catch (e) {
        log(`  FAIL : ${e.message}\n`);
        console.error(e);
      }

      // Test 2: Sort ascending
      log('Test 2: Sort (ascending)');
      try {
        const graph2 = Compiler.createGraph();
        const x2 = Compiler.input(graph2, [8], "input");
        const y2 = Compiler.sort(graph2, x2, 0);  // ascending by default
        Compiler.markOutput(graph2, y2);
        const compiled2 = Compiler.compile(graph2);
        const executor2 = new GraphExecutor(runtime, compiled2);
        await executor2.init();
        
        const input2 = new Float32Array([3, 1, 4, 1, 5, 9, 2, 6]);
        const output2 = await executor2.execute(input2);
        log(`  Input: [${Array.from(input2)}]`);
        log(`  Sort ascending: [${Array.from(output2)}]`);
        log(`  Expected: [1, 1, 2, 3, 4, 5, 6, 9]`);
        const expected2 = [1, 1, 2, 3, 4, 5, 6, 9];
        const pass2 = expected2.every((v, i) => Math.abs(output2[i] - v) < 0.01);
        log(`  ${pass2 ? 'PASS ' : 'FAIL '}\n`);
        executor2.destroy();
      } catch (e) {
        log(`  FAIL : ${e.message}\n`);
        console.error(e);
      }

      // Test 3: Sort descending
      log('Test 3: Sort (descending)');
      try {
        const graph3 = Compiler.createGraph();
        const x3 = Compiler.input(graph3, [8], "input");
        // Note: We need to pass descending=true
        // Since ReScript optional args work differently, let's check the API
        const y3 = Compiler.sort(graph3, x3, 0, true);  // descending
        Compiler.markOutput(graph3, y3);
        const compiled3 = Compiler.compile(graph3);
        const executor3 = new GraphExecutor(runtime, compiled3);
        await executor3.init();
        
        const input3 = new Float32Array([3, 1, 4, 1, 5, 9, 2, 6]);
        const output3 = await executor3.execute(input3);
        log(`  Input: [${Array.from(input3)}]`);
        log(`  Sort descending: [${Array.from(output3)}]`);
        log(`  Expected: [9, 6, 5, 4, 3, 2, 1, 1]`);
        const expected3 = [9, 6, 5, 4, 3, 2, 1, 1];
        const pass3 = expected3.every((v, i) => Math.abs(output3[i] - v) < 0.01);
        log(`  ${pass3 ? 'PASS ' : 'FAIL '}\n`);
        executor3.destroy();
      } catch (e) {
        log(`  FAIL : ${e.message}\n`);
        console.error(e);
      }

      // Test 4: Arange
      log('Test 4: Arange (generate sequence)');
      try {
        const graph4 = Compiler.createGraph();
        const seq = Compiler.arange(graph4, 5);  // [0, 1, 2, 3, 4]
        // Add 10 to make it visible (arange creates a constant)
        const x4 = Compiler.input(graph4, [5], "input");
        const y4 = Compiler.add(graph4, x4, seq);
        Compiler.markOutput(graph4, y4);
        const compiled4 = Compiler.compile(graph4);
        const executor4 = new GraphExecutor(runtime, compiled4);
        await executor4.init();
        
        const input4 = new Float32Array([10, 10, 10, 10, 10]);
        const output4 = await executor4.execute(input4);
        log(`  Arange(5) + [10,10,10,10,10]`);
        log(`  Output: [${Array.from(output4)}]`);
        log(`  Expected: [10, 11, 12, 13, 14]`);
        const expected4 = [10, 11, 12, 13, 14];
        const pass4 = expected4.every((v, i) => Math.abs(output4[i] - v) < 0.01);
        log(`  ${pass4 ? 'PASS ' : 'FAIL '}\n`);
        executor4.destroy();
      } catch (e) {
        log(`  FAIL : ${e.message}\n`);
        console.error(e);
      }

      // Test 5: Sort 2D along axis 1
      log('Test 5: Sort 2D (along axis 1)');
      try {
        const graph5 = Compiler.createGraph();
        const x5 = Compiler.input(graph5, [2, 4], "input");
        const y5 = Compiler.sort(graph5, x5, 1);  // sort each row
        Compiler.markOutput(graph5, y5);
        const compiled5 = Compiler.compile(graph5);
        const executor5 = new GraphExecutor(runtime, compiled5);
        await executor5.init();
        
        // [[4,2,3,1], [8,5,7,6]] -> [[1,2,3,4], [5,6,7,8]]
        const input5 = new Float32Array([4, 2, 3, 1, 8, 5, 7, 6]);
        const output5 = await executor5.execute(input5);
        log(`  Input: [[4,2,3,1], [8,5,7,6]]`);
        log(`  Sort axis 1: [${Array.from(output5)}]`);
        log(`  Expected: [1,2,3,4, 5,6,7,8]`);
        const expected5 = [1, 2, 3, 4, 5, 6, 7, 8];
        const pass5 = expected5.every((v, i) => Math.abs(output5[i] - v) < 0.01);
        log(`  ${pass5 ? 'PASS ' : 'FAIL '}\n`);
        executor5.destroy();
      } catch (e) {
        log(`  FAIL : ${e.message}\n`);
        console.error(e);
      }

      runtime.destroy();
      log('=== All Extra Operations Tests Completed ===');
    }
    
    runTests();
  </script>
</body>
</html>
